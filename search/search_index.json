{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mezzio-swoole This library provides support for Swoole or Open Swoole for Mezzio applications. This means you can execute your Mezzio application using Swoole directly from the command line. Installation Run the following to install this library: $ composer require mezzio/mezzio-swoole Configuration After installing mezzio-swoole, you will need to first enable the component, and then optionally configure it. We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), []); The above will setup Swoole integration for your application. By default, Swoole executes the HTTP server with host 127.0.0.1 on port 8080 . You can change these values via configuration. Assuming you have the above, modify it to read as follows: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'host' =&gt; 'insert hostname to use here', 'port' =&gt; 80, // use an integer value here ], ], ]); Mezzio skeleton 3.1.0 and later If you have built your application on the 3.1.0 or later version of the Mezzio skeleton, you do not need to instantiate and invoke the package's ConfigProvider , as the skeleton supports it out of the box. You will only need to provide any additional configuration of the HTTP server. Execute Once you have performed the configuration steps as outlined above, you can run an Mezzio application with Swoole via the laminas-cli integration: $ ./vendor/bin/laminas mezzio:swoole:start Call the laminas command without arguments to get a list of available commands, looking for those that begin with mezzio:swoole: , and use the help meta-argument to get help on individual commands: $ ./vendor/bin/laminas help mezzio:swoole:start Documentation Browse the documentation online at https://docs.mezzio.dev/mezzio-swoole/ Support Issues Chat Forum","title":"Home"},{"location":"#mezzio-swoole","text":"This library provides support for Swoole or Open Swoole for Mezzio applications. This means you can execute your Mezzio application using Swoole directly from the command line.","title":"mezzio-swoole"},{"location":"#installation","text":"Run the following to install this library: $ composer require mezzio/mezzio-swoole","title":"Installation"},{"location":"#configuration","text":"After installing mezzio-swoole, you will need to first enable the component, and then optionally configure it. We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), []); The above will setup Swoole integration for your application. By default, Swoole executes the HTTP server with host 127.0.0.1 on port 8080 . You can change these values via configuration. Assuming you have the above, modify it to read as follows: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'host' =&gt; 'insert hostname to use here', 'port' =&gt; 80, // use an integer value here ], ], ]);","title":"Configuration"},{"location":"#execute","text":"Once you have performed the configuration steps as outlined above, you can run an Mezzio application with Swoole via the laminas-cli integration: $ ./vendor/bin/laminas mezzio:swoole:start Call the laminas command without arguments to get a list of available commands, looking for those that begin with mezzio:swoole: , and use the help meta-argument to get help on individual commands: $ ./vendor/bin/laminas help mezzio:swoole:start","title":"Execute"},{"location":"#documentation","text":"Browse the documentation online at https://docs.mezzio.dev/mezzio-swoole/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"how_it_works/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/mezzio-swoole/v1/how-it-works/'; });","title":"_how-it-works"},{"location":"intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/mezzio-swoole/v1/intro/'; });","title":"_introduction"},{"location":"logging/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/mezzio-swoole/v1/logging/'; });","title":"_logging"},{"location":"static-resources/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/mezzio-swoole/v1/static-resources/'; });","title":"_static-resources"},{"location":"v1/considerations/","text":"Considerations when using Swoole Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application. Long-running processes When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead. PDO Coroutine Support Please be aware that enabling coroutine support with Swoole\\Runtime::enableCoroutine() only decorates MySql PDO connections with coroutines; other drivers (e.g., pdo_pgsql) remain blocking as of Swoole 4.1.2. &gt; For more details, visit the related bug report on the Swoole issue tracker . Sessions Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives. mezzio-session-cache mezzio-session-cache provides a persistence adapter for mezzio-session that uses a PSR-6 CacheItemPoolInterface implementation for storing and retrieving sessions. This approach requires that you setup a backend cache storage for your session data. psr7-sessions/storageless PSR7Session provides session middleware that uses JWT tokens within the session cookie to transmit session data between the server and client. This approach requires no central session storage, but does impose limits on the amount of information you can store in a session. Stateless services The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail. Decoration If a service implements an interface, you can decorate the service to make it stateless. Well-written interfaces will be stateless by design, and not provide methods meant to internally change state. In these situations, you can create a proxy class that decorates the original service: class ProxyService implements OriginalInterface { /** @var OriginalInterface */ private $proxy; public function __construct(OriginalInterface $proxy) { $this-&gt;proxy = $proxy; } public function someMethodDefinedInInterface(string $argument) : Result { return $this-&gt;proxy-&gt;someMethodDefinedInInterface($argument); } } You would then: Map the factory for the original service to the implementation name. Create a factory that consumes the original service, and produces the proxy. Map the interface name to the factory that creates the proxy. // in config/autoload/dependencies.global.php: return [ 'dependencies' =&gt; [ 'factories' =&gt; [ OriginalImplementation::class =&gt; OriginalImplementationFactory::class, OriginalInterface::class =&gt; ProxyServiceFactory::class, ], ], ]; If you were writing to the interface, and not the implementation, you can now guarantee that any non-interface methods that changed state can now no longer be called. If the interface itself defines methods that modify state, we recommend writing a proxy that implements those methods as no-ops and/or that raises exceptions when those methods are invoked. (The latter approach ensures that you discover quickly when code is exercising those methods.) In each case, you would then use a delegator factory , to decorate the original instance in the proxy class: function (ContainerInterface $container, string $name, callable $callback) { return new ProxyService($callback()); } (You can also use the delegator factory approach with the previous proxy service example.) Extension When a service does not implement an interface, but exposes methods that change internal state, you can extend the original class to make the methods that change state into no-ops, or have them raise exceptions. (The latter approach ensures that you discover quickly when code is exercising those methods.) As an example, let's say you have a class DataMapper that defines a method setTable() in it, and that method would change the database table the mapper would query. This is a potentially bad situation! We could extend the class as follows: class StatelessDataMapper extends DataMapper { public function setTable(string $table) : void { throw new \\DomainException(sprintf( '%s should not be called in production code!', __METHOD__ )); } } In your factory that creates an instance of DataMapper , have it instead return a StatelessDataMapper instance, and you're now safe. Factories Another approach is to modify your consuming code to accept a factory that will produce the service you'll consume, instead of the service itself. This approach ensures that the service is created only when needed, mitigating any state change issues. As an example, consider the following middleware that currently consumes a template renderer: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this-&gt;renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { return new HtmlResponse($this-&gt;renderer-&gt;render( 'app::some-handler', [] )); } } What we will do is modify it to accept a callable to the constructor. We will then call that factory just before we need the renderer; we will not store the result in the handler, as we want to ensure we have a new instance each time. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var callable */ private $rendererFactory; public function __construct(callable $rendererFactory) { $this-&gt;rendererFactory = $rendererFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { /** @var TemplateRendererInterface $renderer */ $renderer = ($this-&gt;rendererFactory)(); return new HtmlResponse($renderer-&gt;render( 'app::some-handler', [] )); } } From here, we create a factory for our dependency injection container that will return the factory we use here. As an example, if we are using the laminas-view integration , we might do the following: use Psr\\Container\\ContainerInterface; use Mezzio\\Template\\TemplateRendererInterface; use Mezzio\\LaminasView\\LaminasViewRendererFactory; class LaminasViewRendererFactoryFactory { public function __invoke(ContainerInterface $container) : callable { $factory = new LaminasViewRendererFactory(); return function () use ($container, $factory) : TemplateRendererInterface { return $factory($container); }; } } If we mapped this to the \"service\" Mezzio\\Template\\TemplateRendererInterfaceFactory , our factory for the SomeHandler class would then look like: use Mezzio\\Template\\TemplateRendererInterfaceFactory; function (ContainerInterface $container) : SomeHandler { return new SomeHandler( $container-&gt;get(TemplateRendererInterfaceFactory::class) ); } This approach ensures we get a new instance with known state at precisely the moment we wish to execute the functionality. By ensuring we do not store the instance in any way, we also ensure it is garbage collected when the instance goes out of scope (i.e., when the method ends). Handling the template data problem If we want our services to be stateless, how do we handle problems such as the documented addDefaultParam() issue referenced earlier ? In this case, the original problem was \"how do we get common request data into templates?\" The solution originally provided was to alter the state of the template renderer. Another solution, however, is one we've also documented previously: use server attributes to pass data between middleware . In this particular case, the middleware documented in the original solution could be modified to provide data to a request attribute, instead of altering the state of the template renderer. It might then become: namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Mezzio\\Router\\RouteResult; use Mezzio\\Session\\Authentication\\UserInterface; use Mezzio\\Session\\Flash\\FlashMessagesInterface; class TemplateDefaultsMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $routeResult = $request-&gt;getAttribute(RouteResult::class); $flashMessages = $request-&gt;getAttribute(FlashMessagesInterface::class); $defaults = [ // Inject the current user, or null if there isn't one. // This is named security so it will not interfere with your user admin pages 'security' =&gt; $request-&gt;getAttribute(UserInterface::class), // Inject the currently matched route name. 'matchedRouteName' =&gt; $routeResult ? $routeResult-&gt;getMatchedRouteName() : null, // Inject all flash messages 'notifications' =&gt; $flashMessages ? $flashMessages-&gt;getFlashes() : [], ]; return $handler-&gt;handle($request-&gt;withAttribute(__CLASS__, $defaults)); } } Once that change is made, you would then change your handler to do the following: Pull that attribute, providing a default [] value. Merge the pulled value with any local values when rendering the template. For example: $defaultParams = $request-&gt;getAttribute(TemplateDefaultsMiddleware::class, []); return new HtmlResponse($renderer-&gt;render( 'some::template', array_merge($defaultParams, [ // handler-specific parameters here ]) )); This approach, while it requires more work on the part of handler authors, ensures that the renderer state does not vary between requests, making it safer for usage with Swoole and other long-running processes.","title":"Considerations when using Swoole"},{"location":"v1/considerations/#considerations-when-using-swoole","text":"Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application.","title":"Considerations when using Swoole"},{"location":"v1/considerations/#long-running-processes","text":"When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead.","title":"Long-running processes"},{"location":"v1/considerations/#sessions","text":"Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives.","title":"Sessions"},{"location":"v1/considerations/#stateless-services","text":"The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail.","title":"Stateless services"},{"location":"v1/how-it-works/","text":"How it works When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation looks similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling. Performance The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.swoole-http-server.options.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"How it works"},{"location":"v1/how-it-works/#how-it-works","text":"When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation looks similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling.","title":"How it works"},{"location":"v1/how-it-works/#performance","text":"The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.swoole-http-server.options.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"Performance"},{"location":"v1/intro/","text":"Swoole Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel. Install swoole You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL . Install mezzio-swoole To install this package, use Composer : $ composer require mezzio/mezzio-swoole Swoole with Mezzio mezzio-swoole enables an Mezzio application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ php public/index.php This command will execute Swoole on localhost via port 8080 . Mezzio skeleton versions prior to 3.1.0 The above will work immediately after installing mezzio-swoole if you are using a version of mezzio-skeleton from 3.1.0 or later. For applications based on previous versions of the skeleton, you will need to create a configuration file such as config/autoload/mezzio-swoole.global.php or config/autoload/mezzio-swoole.local.php with the following contents: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return (new ConfigProvider())(); You can change the host address and/or host name as well as the port using a configuration file, as follows: // In config/autoload/swoole.local.php: return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, ], ], ]; Providing additional Swoole configuration You can also configure the Swoole HTTP server using an options key to specify any accepted Swoole settings. For instance, the following configuration demonstrates enabling SSL: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, 'mode' =&gt; SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS; // SWOOLE_BASE is the default 'protocol' =&gt; SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server 'options' =&gt; [ // Set the SSL certificate and key paths for SSL support: 'ssl_cert_file' =&gt; 'path/to/ssl.crt', 'ssl_key_file' =&gt; 'path/to/ssl.key', // Available in Swoole 4.1 and up; enables coroutine support // for most I/O operations: 'enable_coroutine' =&gt; true, ], ], ], ]; Serving static files We support serving static files. By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Our static resource capabilities are fairly comprehensive; please see the chapter on static resources for full details on configuration.","title":"Intro"},{"location":"v1/intro/#swoole","text":"Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel.","title":"Swoole"},{"location":"v1/intro/#install-swoole","text":"You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL .","title":"Install swoole"},{"location":"v1/intro/#install-mezzio-swoole","text":"To install this package, use Composer : $ composer require mezzio/mezzio-swoole","title":"Install mezzio-swoole"},{"location":"v1/intro/#swoole-with-mezzio","text":"mezzio-swoole enables an Mezzio application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ php public/index.php This command will execute Swoole on localhost via port 8080 .","title":"Swoole with Mezzio"},{"location":"v1/logging/","text":"Logging Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400). Access Logs Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically. Formatting logs The Apache web server has long provided flexible and robust logging capabilities, and its formats are used across a variety of web servers and logging platforms. As such, we have chosen to use its formats for our standard implementation. However, we allow you to plug in your own system as needed. You can refer to the Apache mod_log_config documentation in order to understand the available placeholders available for format strings. Formatting is provided to the Psr3AccessLogDecorator via instances of the interface Mezzio\\Swoole\\Log\\AccessLogFormatterInterface : interface AccessLogFormatterInterface { public function format(AccessLogDataMap $map) : string; } AccessLogDataMap is a class used internally by the Psr3AccessLogDecorator in order to map Apache log placeholders to request/response values. Our default AccessLogFormatterInterface implementation, AccessLogFormatter , provides constants referencing the most common formats, but also allows you to use arbitrary log formats that use the standard Apache placeholders. The formats we include by default are: AccessLogFormatter::FORMAT_COMMON : Apache common log format: %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost: %v %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMBINED : Apache combined log format: %h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-Agent}i\" AccessLogFormatter::FORMAT_REFERER : %{Referer}i -&gt; %U AccessLogFormatter::FORMAT_AGENT : %{User-Agent}i AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %&gt;s %b'; AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format: %h %l %u %t “%r” %&gt;s %O ; AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format: %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i” ; AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost: %v:%p %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i\" ; Configuring a logger You may subsitute your own logger implementation into the Swoole request handler runner. Manual usage If you are manually instantiating a Mezzio\\Swoole\\SwooleRequestHandlerRunner instance, you may provide it as the seventh argument to the constructor: use Mezzio\\Swoole\\SwooleRequestHandlerRunner; $runner = new SwooleRequestHandlerRunner( $application, $serverRequestFactory, $serverRequestErrorResponseGenerator, $pidManager, $serverFactory, $staticResourceHandler, $logger // &lt;-- AccessLoggerInterface instance ); Container usage If you are using a PSR-11 container, the SwooleRequestHandlerRunnerFactory will retrieve a log instance using the Mezzio\\Swoole\\Log\\AccessLogInterface service. You have two options for substituting your own logger from there. First, you can create your own factory that produces an AccessLogInterface instance, and map it to the service. This is the best route if you want to write your own implementation, or want to use a different PSR-3 logger service. If you are okay with re-using your existing PSR-3 logger, the provided Mezzio\\Swoole\\Log\\AccessLogFactory will use the Psr\\Log\\LoggerInterface service to create a Psr3AccessLogDecorator instance. This factory also allows you to specify a custom AccessLogFormatterInterface instance if you want. It will look up a service by the fully-qualified interface name, and use it if present. Otherwise, it creates an AccessLogFormatter instance for you. The factory will also look at the following configuration values: 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'logger' =&gt; [ 'format' =&gt; string, // one of the AccessLogFormatter::FORMAT_* // constants, or a custom format string 'use-hostname-lookups' =&gt; bool, // Set to true to enable hostname lookups ], ], ], Using Monolog as a PSR-3 logger When using Monolog with a StreamHandler , you must supply a file or a stream resource descriptor. We recommend using one of the following: php://stdout is a good choice, as this will generally write to the current console. php://stderr is also a good choice, as this will generally write to the current console, and allows you to filter based on that output stream. When using Docker , generally one of either /proc/1/fd/1 or /proc/1/fd/2 can be used, and are analogous to STDOUT and STDERR , respectively. We recommend using php://stdout and php://stderr instead, as these will be mapped to the correct locations by the language. ErrorLogHandler If you plan to write to STDERR , you might consider instead using the Monolog ErrorLogHandler , as this will use PHP's error_log() mechanism to write to the configured PHP error log. You can then either introspect that location, or configure the error_log php.ini setting to point to either /dev/stderr or, if on Docker, /proc/1/fd/2 . Additionally, we recommend using the PsrLogMessageProcessor with any Monolog handler to ensure that any templated parameters are expanded by the logger. As an example, the following is a factory that wires a StreamHandler to a Monolog\\Logger instance. use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use Monolog\\Processor\\PsrLogMessageProcessor; class LoggerFactory { public function __invoke(ContainerInterface $container) : LoggerInterface { $logger = new Logger('swoole-http-server'); $logger-&gt;pushHandler(new StreamHandler( 'php://stdout', Logger::INFO, $bubble = true, $expandNewLines = true )); $logger-&gt;pushProcessor(new PsrLogMessageProcessor()); return $logger; } } If you then wire this to the Psr\\Log\\LoggerInterface service, it will be used by Swoole for the purposes of access logs as well.","title":"Logging"},{"location":"v1/logging/#logging","text":"Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400).","title":"Logging"},{"location":"v1/logging/#access-logs","text":"Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically.","title":"Access Logs"},{"location":"v1/logging/#configuring-a-logger","text":"You may subsitute your own logger implementation into the Swoole request handler runner.","title":"Configuring a logger"},{"location":"v1/static-resources/","text":"Static Resources One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Middleware The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers). Providing your own middleware If you want to disable middleware, or to provide an alternate list of middleware (including your own!), you will need to provide an alternate StaticResourceHandler factory. In most cases, you can extend StaticResourceHandlerFactory and override the configureMiddleware(array $config) : array method to do so. Be sure to remember to add a dependencies setting mapping the StaticResourceHandlerInterface service to your new factory when done! Configuration We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ]; Security warning Never add php as an allowed static file extension, as doing so could expose the source code of your PHP application! Document root If no document_root configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root does not exist, we raise an exception. Default extension/content-types By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Configuration Example The example which follows provides the following options: Sets the document root to /var/www/htdocs . Adds a custom extension / content-type map. Provides a clearstatcache interval of 2 hours. Selects the \"strong\" ETag algorithm. Indicates a gzip compression level of 3. Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files. Sets Cache-Control directives for plain text files. // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'document-root' =&gt; '/var/www/htdocs', 'type-map' =&gt; [ 'css' =&gt; 'text/css', 'gif' =&gt; 'image/gif', 'ico' =&gt; 'image/x-icon', 'jpg' =&gt; 'image/jpg', 'jpeg' =&gt; 'image/jpg', 'js' =&gt; 'application/javascript', 'png' =&gt; 'image/png', 'svg' =&gt; 'image/svg+xml', 'txt' =&gt; 'text/plain', ], 'clearstatcache-interval' =&gt; 7200, 'etag-type' =&gt; 'strong', 'gzip' =&gt; [ 'level' =&gt; 3, ], 'directives' =&gt; [ '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-transform', ], 'last-modified' =&gt; true, 'etag' =&gt; true, ], '/\\.txt$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-cache', ], ], ], ], ], ], ]; Writing Middleware Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() . Providing an alternative mechanism for sending response content In some cases, you may want to alter how the Swoole\\Http\\Response receives the body content. By default, we use Swoole\\Http\\Response::sendfile() . However, this may not work well when performing tasks such as compression, appending a watermark, etc. As an example, the GzipMiddleware adds a compression filter to a filehandle representing the file to send, and then calls Swoole\\Http\\Response::write() in a loop until all content is sent. To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback() method as detailed in the section above within your middleware. Alternative static resource handlers As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Static Resources"},{"location":"v1/static-resources/#static-resources","text":"One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it.","title":"Static Resources"},{"location":"v1/static-resources/#middleware","text":"The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers).","title":"Middleware"},{"location":"v1/static-resources/#configuration","text":"We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ];","title":"Configuration"},{"location":"v1/static-resources/#writing-middleware","text":"Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() .","title":"Writing Middleware"},{"location":"v1/static-resources/#alternative-static-resource-handlers","text":"As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Alternative static resource handlers"},{"location":"v2/async-tasks/","text":"Triggering Async Tasks Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes — allowing your application to continue responding to requests while the server processes your task. Configuring the Server Process In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they triggered, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute one after the other. 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; true, //optional to enable coroutines and useful for tasks coroutines 'swoole-http-server' =&gt; [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 8080, 'options' =&gt; [ 'worker_num' =&gt; 4, // The number of HTTP Server Workers 'task_worker_num' =&gt; 4, // The number of Task Workers 'task_enable_coroutine' =&gt; true, // optional to turn on task coroutine support ], ], ]; No CLI option for task_worker_num Unlike worker_num , there is no CLI option for task_worker_num . This is because enabling the task worker also requires registering a task worker with the server. To prevent accidental startup failures due to passing an option to specify the number of task workers without having registered a task worker, we omitted the CLI option. Task Event Handlers When task workers are enabled, the Swoole server will now require that you register two event callbacks with the server; without them, the server will refuse to start. The two events are: task , which will define the code for handling tasks. finish , which will execute when a task has completed. Registering the Handlers The signature for the task event handler is: function ( \\Swoole\\Http\\Server $server, int $taskId, int $sourceWorkerId, $dataForWorker ) : void where: $server is the main HTTP server process $taskId is a number that increments each time the server triggers a new task. $sourceWorkerId is an integer that defines the worker process that is executing the workload. $dataForWorker contains the value passed to the $server-&gt;task() method when initially triggering the task. This value can be any PHP value, with the exception of a resource . If coroutine support is enabled for tasks, the signature for the task event handler is: function ( \\Swoole\\Http\\Server $server, \\Swoole\\Server\\Task $task ) : void where: $server is the main HTTP server process $task-&gt;id is a number that increments each time the server triggers a new task. $task-&gt;worker_id is an integer that defines the worker process that is executing the workload. $task-&gt;data contains the value passed to the $server-&gt;task() method when initially triggering the task. This value can be any PHP value, with the exception of a resource . $task-&gt;flag is the type of task To register the handler with the server, you must call it's on() method, before the server has been started: $server-&gt;on('task', $callable); As previously mentioned, you must also register an event handler for the finish event. This callback for this event should have the following signature: function ( \\Swoole\\Http\\Server $server, int $taskId, $userData ) : void The first two parameters are identical to the task event handler. The $userData parameter will contain the return value of the task event handler. Registering your callable for the finish event is accomplished like this: $server-&gt;on('finish', $callable); There can be only one There can be only one event handler per event type. Subsequent calls to on('&lt;EventName&gt;') replace the previously registered callable. Finishing a task If you do not return anything from your task event handler, the finish handler will not be called . The Swoole documentation recommends that the task worker callback manually finish the task in these situations: $server-&gt;finish(''); Even if you do not call the above method, the handler must be defined, or the server will refuse to start. An example task worker The following example code illustrates a task worker with logging capabilities that uses a message notifier to process data: // In src/App/TaskWorker.php: namespace App; use Psr\\EventDispatcher\\MessageInterface; use Psr\\EventDispatcher\\MessageNotifierInterface; use Psr\\Log\\LoggerInterface; use Throwable; class TaskWorker { private $notifier; private $logger; public function __construct(LoggerInterface $logger, MessageNotifierInterface $notifier) { $this-&gt;logger = $logger; $this-&gt;notifier = $notifier; } public function __invoke($server, $taskId, $fromId, $data) { if (! $data instanceof MessageInterface) { $this-&gt;logger-&gt;error('Invalid data type provided to task worker: {type}', [ 'type' =&gt; is_object($data) ? get_class($data) : gettype($data) ]); return; } $this-&gt;logger-&gt;notice('Starting work on task {taskId} using data: {data}', [ 'taskId' =&gt; $taskId, 'data' =&gt; json_encode($data), ]); try { $this-&gt;notifier-&gt;notify($data); } catch (Throwable $e) { $this-&gt;logger-&gt;error('Error processing task {taskId}: {error}', [ 'taskId' =&gt; $taskId, 'error' =&gt; $e-&gt;getTraceAsString(), ]); } // Notify the server that processing of the task has finished: $server-&gt;finish(''); } } This invokable class needs to be attached to the $server-&gt;on('task') event before the server has started. The easiest place to accomplish this is in a delegator factory targeting the Swoole HTTP server. First, we'll create the delegator factory: // In src/App/TaskWorkerDelegator.php: namespace App; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Server as HttpServer; class TaskWorkerDelegator { public function __invoke(ContainerInterface $container, $serviceName, callable $callback) : HttpServer { $server = $callback(); $logger = $container-&gt;get(LoggerInterface::class); $server-&gt;on('task', $container-&gt;get(TaskWorker::class)); $server-&gt;on('finish', function ($server, $taskId, $data) use ($logger) { $logger-&gt;notice('Task #{taskId} has finished processing', ['taskId' =&gt; $taskId]); }); return $server; } } Next, we'll register it with our container: // In config/autoload/dependencies.php: return [ 'dependencies' =&gt; [ 'delegators' =&gt; [ \\Swoole\\Http\\Server::class =&gt; [ \\App\\TaskWorkerDelegator::class, ], ], ], ]; With this in place, we can now trigger tasks within our application. In the scenario outlined above, the task worker expects messages ; it then notifies listeners of that message so they may respond to it. Triggering Tasks in Middleware Considering that this library provides an application runner for middleware applications, you will likely trigger tasks from within your middleware or request handlers. In each case, you will need to compose the Swoole HTTP server instance as a class dependency, as tasks are triggered via the server via its task() method. The method can accept any value except a resource as an argument. In the example below, ContactMessage will implement the MessageInterface from the above example. The request handler uses values from the request to create the ContactMessage instance, and then create a task from it. It then immediately returns a response. // in src/App/Handler/TaskTriggeringHandler.php: namespace App\\Handler; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Swoole\\Http\\Server as HttpServer; use Mezzio\\Template\\TemplateRendererInterface; class TaskTriggeringHandler implements RequestHandlerInterface { private $responseFactory; private $server; private $template; public function __construct( HttpServer $server, TemplateRendererInterface $template, ResponseFactoryInterface $responseFactory ) { $this-&gt;server = $server; $this-&gt;template = $template; $this-&gt;responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // Gather data from request $data = $request-&gt;getParsedBody(); // A fictonal event describing a contact request: $event = new ContactEvent([ 'to' =&gt; $data['email'], 'subject' =&gt; $data['subject'], 'message' =&gt; $data['message'], ]); // task() returns a task identifier, if you want to use it; otherwise, // you can ignore the return value. $taskIdentifier = $this-&gt;server-&gt;task($event); // The task() method is asynchronous, so execution continues immediately. $response = ($this-&gt;responseFactory()-&gt;createResponse()) -&gt;withHeader('Content-Type', 'text/html'); $response-&gt;getBody()-&gt;write($this-&gt;template-&gt;render('contact::thank-you', []); return $response; } }","title":"Async Tasks"},{"location":"v2/async-tasks/#triggering-async-tasks","text":"Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes — allowing your application to continue responding to requests while the server processes your task.","title":"Triggering Async Tasks"},{"location":"v2/async-tasks/#configuring-the-server-process","text":"In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they triggered, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute one after the other. 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; true, //optional to enable coroutines and useful for tasks coroutines 'swoole-http-server' =&gt; [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 8080, 'options' =&gt; [ 'worker_num' =&gt; 4, // The number of HTTP Server Workers 'task_worker_num' =&gt; 4, // The number of Task Workers 'task_enable_coroutine' =&gt; true, // optional to turn on task coroutine support ], ], ];","title":"Configuring the Server Process"},{"location":"v2/async-tasks/#task-event-handlers","text":"When task workers are enabled, the Swoole server will now require that you register two event callbacks with the server; without them, the server will refuse to start. The two events are: task , which will define the code for handling tasks. finish , which will execute when a task has completed.","title":"Task Event Handlers"},{"location":"v2/async-tasks/#an-example-task-worker","text":"The following example code illustrates a task worker with logging capabilities that uses a message notifier to process data: // In src/App/TaskWorker.php: namespace App; use Psr\\EventDispatcher\\MessageInterface; use Psr\\EventDispatcher\\MessageNotifierInterface; use Psr\\Log\\LoggerInterface; use Throwable; class TaskWorker { private $notifier; private $logger; public function __construct(LoggerInterface $logger, MessageNotifierInterface $notifier) { $this-&gt;logger = $logger; $this-&gt;notifier = $notifier; } public function __invoke($server, $taskId, $fromId, $data) { if (! $data instanceof MessageInterface) { $this-&gt;logger-&gt;error('Invalid data type provided to task worker: {type}', [ 'type' =&gt; is_object($data) ? get_class($data) : gettype($data) ]); return; } $this-&gt;logger-&gt;notice('Starting work on task {taskId} using data: {data}', [ 'taskId' =&gt; $taskId, 'data' =&gt; json_encode($data), ]); try { $this-&gt;notifier-&gt;notify($data); } catch (Throwable $e) { $this-&gt;logger-&gt;error('Error processing task {taskId}: {error}', [ 'taskId' =&gt; $taskId, 'error' =&gt; $e-&gt;getTraceAsString(), ]); } // Notify the server that processing of the task has finished: $server-&gt;finish(''); } } This invokable class needs to be attached to the $server-&gt;on('task') event before the server has started. The easiest place to accomplish this is in a delegator factory targeting the Swoole HTTP server. First, we'll create the delegator factory: // In src/App/TaskWorkerDelegator.php: namespace App; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Server as HttpServer; class TaskWorkerDelegator { public function __invoke(ContainerInterface $container, $serviceName, callable $callback) : HttpServer { $server = $callback(); $logger = $container-&gt;get(LoggerInterface::class); $server-&gt;on('task', $container-&gt;get(TaskWorker::class)); $server-&gt;on('finish', function ($server, $taskId, $data) use ($logger) { $logger-&gt;notice('Task #{taskId} has finished processing', ['taskId' =&gt; $taskId]); }); return $server; } } Next, we'll register it with our container: // In config/autoload/dependencies.php: return [ 'dependencies' =&gt; [ 'delegators' =&gt; [ \\Swoole\\Http\\Server::class =&gt; [ \\App\\TaskWorkerDelegator::class, ], ], ], ]; With this in place, we can now trigger tasks within our application. In the scenario outlined above, the task worker expects messages ; it then notifies listeners of that message so they may respond to it.","title":"An example task worker"},{"location":"v2/async-tasks/#triggering-tasks-in-middleware","text":"Considering that this library provides an application runner for middleware applications, you will likely trigger tasks from within your middleware or request handlers. In each case, you will need to compose the Swoole HTTP server instance as a class dependency, as tasks are triggered via the server via its task() method. The method can accept any value except a resource as an argument. In the example below, ContactMessage will implement the MessageInterface from the above example. The request handler uses values from the request to create the ContactMessage instance, and then create a task from it. It then immediately returns a response. // in src/App/Handler/TaskTriggeringHandler.php: namespace App\\Handler; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Swoole\\Http\\Server as HttpServer; use Mezzio\\Template\\TemplateRendererInterface; class TaskTriggeringHandler implements RequestHandlerInterface { private $responseFactory; private $server; private $template; public function __construct( HttpServer $server, TemplateRendererInterface $template, ResponseFactoryInterface $responseFactory ) { $this-&gt;server = $server; $this-&gt;template = $template; $this-&gt;responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // Gather data from request $data = $request-&gt;getParsedBody(); // A fictonal event describing a contact request: $event = new ContactEvent([ 'to' =&gt; $data['email'], 'subject' =&gt; $data['subject'], 'message' =&gt; $data['message'], ]); // task() returns a task identifier, if you want to use it; otherwise, // you can ignore the return value. $taskIdentifier = $this-&gt;server-&gt;task($event); // The task() method is asynchronous, so execution continues immediately. $response = ($this-&gt;responseFactory()-&gt;createResponse()) -&gt;withHeader('Content-Type', 'text/html'); $response-&gt;getBody()-&gt;write($this-&gt;template-&gt;render('contact::thank-you', []); return $response; } }","title":"Triggering Tasks in Middleware"},{"location":"v2/command-line/","text":"Command Line Tooling This package ships the vendor binary mezzio-swoole . It provides the following commands: start to start the server stop to stop the server (when run in daemonized mode) reload to reload the server (when run in daemonized mode) status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/mezzio-swoole help start The stop , status , and reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The start command, however, may need customizations if you have customized your application bootstrap. The start command The start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Mezzio\\Application and Mezzio\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Mezzio skeleton application. Writing a custom start command If your application needs alternate bootstrapping (e.g., if you have modified the public/index.php , or if you are using this package with a different middleware runtime), we recommend writing a custom start command. As an example, let's say you have altered your application such that you're defining your routes in multiple files, and instead of: (require 'config/routes.php')($app, $factory, $container); you instead have something like: $handle = opendir('config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } You could write a command such as the following: // In src/App/Command/StartCommand.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; use Swoole\\Http\\Server as SwooleHttpServer; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; use Mezzio\\Application; use Mezzio\\MiddlewareFactory; use Mezzio\\Swoole\\Command\\StartCommand as BaseStartCommand; use Mezzio\\Swoole\\PidManager; class StartCommand extends BaseStartCommand { protected function execute(InputInterface $input, OutputInterface $output) : int { // This functionality is identical to the base start command, and should // be copy and pasted to your implementation: $this-&gt;pidManager = $this-&gt;container-&gt;get(PidManager::class); if ($this-&gt;isRunning()) { $output-&gt;writeln('&lt;error&gt;Server is already running!&lt;/error&gt;'); return 1; } $server = $this-&gt;container-&gt;get(SwooleHttpServer::class); $server-&gt;set([ 'daemonize' =&gt; $input-&gt;getOption('daemonize'), 'worker_num' =&gt; $input-&gt;getOption('num-workers') ?? self::DEFAULT_NUM_WORKERS, ]); /** @var \\Mezzio\\Application $app */ $app = $this-&gt;container-&gt;get(Application::class); /** @var \\Mezzio\\MiddlewareFactory $factory */ $factory = $this-&gt;container-&gt;get(MiddlewareFactory::class); // Execute programmatic/declarative middleware pipeline and routing // configuration statements (require 'config/pipeline.php')($app, $factory, $this-&gt;container); // // This is the new code from above: // $handle = opendir(getcwd() . '/config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } // And now we return to the original code: // Run the application $app-&gt;run(); return 0; } } You will also need to write a factory for the class: // In src/App/Command/StartCommandFactory.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; class StartCommandFactory { public function __invoke(ContainerInterface $container) : StartCommand { return new StartCommand($container); } } If this is all you're changing, you can map this new command to the existing Mezzio\\Swoole\\Command\\StartCommand service within your configuration: // in config/autoload/dependencies.global.php: use App\\Command\\StartCommandFactory; use Mezzio\\Swoole\\Command\\StartCommand; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ StartCommand::class =&gt; StartCommandFactory::class, ], ], ]; Since the mezzio-swoole binary uses your application configuration and container, this will substitute your command for the shipped command!","title":"Command Line Tooling"},{"location":"v2/command-line/#command-line-tooling","text":"This package ships the vendor binary mezzio-swoole . It provides the following commands: start to start the server stop to stop the server (when run in daemonized mode) reload to reload the server (when run in daemonized mode) status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/mezzio-swoole help start The stop , status , and reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The start command, however, may need customizations if you have customized your application bootstrap.","title":"Command Line Tooling"},{"location":"v2/command-line/#the-start-command","text":"The start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Mezzio\\Application and Mezzio\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Mezzio skeleton application.","title":"The start command"},{"location":"v2/considerations/","text":"Considerations when using Swoole Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application. Long-running processes When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead. PDO Coroutine Support Please be aware that enabling coroutine support with Swoole\\Runtime::enableCoroutine() only decorates MySql PDO connections with coroutines; other drivers (e.g., pdo_pgsql) remain blocking as of Swoole 4.1.2. For more details, visit the related bug report on the Swoole issue tracker . Sessions Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives. mezzio-session-cache mezzio-session-cache provides a persistence adapter for mezzio-session that uses a PSR-6 CacheItemPoolInterface implementation for storing and retrieving sessions. This approach requires that you setup a backend cache storage for your session data. psr7-sessions/storageless PSR7Session provides session middleware that uses JWT tokens within the session cookie to transmit session data between the server and client. This approach requires no central session storage, but does impose limits on the amount of information you can store in a session. Stateless services The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail. Decoration If a service implements an interface, you can decorate the service to make it stateless. Well-written interfaces will be stateless by design, and not provide methods meant to internally change state. In these situations, you can create a proxy class that decorates the original service: class ProxyService implements OriginalInterface { /** @var OriginalInterface */ private $proxy; public function __construct(OriginalInterface $proxy) { $this-&gt;proxy = $proxy; } public function someMethodDefinedInInterface(string $argument) : Result { return $this-&gt;proxy-&gt;someMethodDefinedInInterface($argument); } } You would then: Map the factory for the original service to the implementation name. Create a factory that consumes the original service, and produces the proxy. Map the interface name to the factory that creates the proxy. // in config/autoload/dependencies.global.php: return [ 'dependencies' =&gt; [ 'factories' =&gt; [ OriginalImplementation::class =&gt; OriginalImplementationFactory::class, OriginalInterface::class =&gt; ProxyServiceFactory::class, ], ], ]; If you were writing to the interface, and not the implementation, you can now guarantee that any non-interface methods that changed state can now no longer be called. If the interface itself defines methods that modify state, we recommend writing a proxy that implements those methods as no-ops and/or that raises exceptions when those methods are invoked. (The latter approach ensures that you discover quickly when code is exercising those methods.) In each case, you would then use a delegator factory , to decorate the original instance in the proxy class: function (ContainerInterface $container, string $name, callable $callback) { return new ProxyService($callback()); } (You can also use the delegator factory approach with the previous proxy service example.) Extension When a service does not implement an interface, but exposes methods that change internal state, you can extend the original class to make the methods that change state into no-ops, or have them raise exceptions. (The latter approach ensures that you discover quickly when code is exercising those methods.) As an example, let's say you have a class DataMapper that defines a method setTable() in it, and that method would change the database table the mapper would query. This is a potentially bad situation! We could extend the class as follows: class StatelessDataMapper extends DataMapper { public function setTable(string $table) : void { throw new \\DomainException(sprintf( '%s should not be called in production code!', __METHOD__ )); } } In your factory that creates an instance of DataMapper , have it instead return a StatelessDataMapper instance, and you're now safe. Factories Another approach is to modify your consuming code to accept a factory that will produce the service you'll consume, instead of the service itself. This approach ensures that the service is created only when needed, mitigating any state change issues. As an example, consider the following middleware that currently consumes a template renderer: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this-&gt;renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { return new HtmlResponse($this-&gt;renderer-&gt;render( 'app::some-handler', [] )); } } What we will do is modify it to accept a callable to the constructor. We will then call that factory just before we need the renderer; we will not store the result in the handler, as we want to ensure we have a new instance each time. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var callable */ private $rendererFactory; public function __construct(callable $rendererFactory) { $this-&gt;rendererFactory = $rendererFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { /** @var TemplateRendererInterface $renderer */ $renderer = ($this-&gt;rendererFactory)(); return new HtmlResponse($renderer-&gt;render( 'app::some-handler', [] )); } } From here, we create a factory for our dependency injection container that will return the factory we use here. As an example, if we are using the laminas-view integration , we might do the following: use Psr\\Container\\ContainerInterface; use Mezzio\\Template\\TemplateRendererInterface; use Mezzio\\LaminasView\\LaminasViewRendererFactory; class LaminasViewRendererFactoryFactory { public function __invoke(ContainerInterface $container) : callable { $factory = new LaminasViewRendererFactory(); return function () use ($container, $factory) : TemplateRendererInterface { return $factory($container); }; } } If we mapped this to the \"service\" Mezzio\\Template\\TemplateRendererInterfaceFactory , our factory for the SomeHandler class would then look like: use Mezzio\\Template\\TemplateRendererInterfaceFactory; function (ContainerInterface $container) : SomeHandler { return new SomeHandler( $container-&gt;get(TemplateRendererInterfaceFactory::class) ); } This approach ensures we get a new instance with known state at precisely the moment we wish to execute the functionality. By ensuring we do not store the instance in any way, we also ensure it is garbage collected when the instance goes out of scope (i.e., when the method ends). Handling the template data problem If we want our services to be stateless, how do we handle problems such as the documented addDefaultParam() issue referenced earlier ? In this case, the original problem was \"how do we get common request data into templates?\" The solution originally provided was to alter the state of the template renderer. Another solution, however, is one we've also documented previously: use server attributes to pass data between middleware . In this particular case, the middleware documented in the original solution could be modified to provide data to a request attribute, instead of altering the state of the template renderer. It might then become: namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Mezzio\\Router\\RouteResult; use Mezzio\\Session\\Authentication\\UserInterface; use Mezzio\\Session\\Flash\\FlashMessagesInterface; class TemplateDefaultsMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $routeResult = $request-&gt;getAttribute(RouteResult::class); $flashMessages = $request-&gt;getAttribute(FlashMessagesInterface::class); $defaults = [ // Inject the current user, or null if there isn't one. // This is named security so it will not interfere with your user admin pages 'security' =&gt; $request-&gt;getAttribute(UserInterface::class), // Inject the currently matched route name. 'matchedRouteName' =&gt; $routeResult ? $routeResult-&gt;getMatchedRouteName() : null, // Inject all flash messages 'notifications' =&gt; $flashMessages ? $flashMessages-&gt;getFlashes() : [], ]; return $handler-&gt;handle($request-&gt;withAttribute(__CLASS__, $defaults)); } } Once that change is made, you would then change your handler to do the following: Pull that attribute, providing a default [] value. Merge the pulled value with any local values when rendering the template. For example: $defaultParams = $request-&gt;getAttribute(TemplateDefaultsMiddleware::class, []); return new HtmlResponse($renderer-&gt;render( 'some::template', array_merge($defaultParams, [ // handler-specific parameters here ]) )); This approach, while it requires more work on the part of handler authors, ensures that the renderer state does not vary between requests, making it safer for usage with Swoole and other long-running processes.","title":"Considerations when using Swoole"},{"location":"v2/considerations/#considerations-when-using-swoole","text":"Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application.","title":"Considerations when using Swoole"},{"location":"v2/considerations/#long-running-processes","text":"When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead.","title":"Long-running processes"},{"location":"v2/considerations/#sessions","text":"Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives.","title":"Sessions"},{"location":"v2/considerations/#stateless-services","text":"The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail.","title":"Stateless services"},{"location":"v2/hot-code-reload/","text":"Hot Code Reload Since 2.3.0 To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production! Requirements ext-inotify This library ships with an inotify based implementation of Mezzio\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded. Configuration The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'hot-code-reload' =&gt; [ // Set to true to enable hot code reload; the default is false. 'enable' =&gt; true, // Time in milliseconds between checks to changes in files. 'interval' =&gt; 500, ], ], ]; Logging When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation. Limitations Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Hot Code Reloading"},{"location":"v2/hot-code-reload/#hot-code-reload","text":"Since 2.3.0 To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production!","title":"Hot Code Reload"},{"location":"v2/hot-code-reload/#requirements","text":"ext-inotify This library ships with an inotify based implementation of Mezzio\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded.","title":"Requirements"},{"location":"v2/hot-code-reload/#configuration","text":"The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'hot-code-reload' =&gt; [ // Set to true to enable hot code reload; the default is false. 'enable' =&gt; true, // Time in milliseconds between checks to changes in files. 'interval' =&gt; 500, ], ], ];","title":"Configuration"},{"location":"v2/hot-code-reload/#logging","text":"When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation.","title":"Logging"},{"location":"v2/hot-code-reload/#limitations","text":"Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Limitations"},{"location":"v2/how-it-works/","text":"How it works When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation acts similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling. Performance The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"How it works"},{"location":"v2/how-it-works/#how-it-works","text":"When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation acts similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling.","title":"How it works"},{"location":"v2/how-it-works/#performance","text":"The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"Performance"},{"location":"v2/intro/","text":"Swoole Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel. Install swoole You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL . Install mezzio-swoole To install this package, use Composer : $ composer require mezzio/mezzio-swoole Swoole with Mezzio mezzio-swoole enables an Mezzio application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/mezzio-swoole start This command will execute Swoole on localhost via port 8080 . Other commands To get a list of all available commands, run the command without arguments: $ ./vendor/bin/mezzio-swoole If you add the argument help before any command name, the tooling will provide you with more detailed information on that command. Mezzio skeleton versions prior to 3.1.0 The above will work immediately after installing mezzio-swoole if you are using a version of mezzio-skeleton from 3.1.0 or later. For applications based on previous versions of the skeleton, you will need to create a configuration file such as config/autoload/mezzio-swoole.global.php or config/autoload/mezzio-swoole.local.php with the following contents: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return (new ConfigProvider())(); You can change the host address and/or host name as well as the port using a configuration file, as follows: // In config/autoload/swoole.local.php: return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, ], ], ]; Providing additional Swoole configuration You can also configure the Swoole HTTP server using an options key to specify any accepted Swoole settings. For instance, the following configuration demonstrates enabling SSL: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ // Available in Swoole 4.1 and up; enables coroutine support // for most I/O operations: 'enable_coroutine' =&gt; true, // Configure Swoole HTTP Server: 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, 'mode' =&gt; SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS; // SWOOLE_BASE is the default 'protocol' =&gt; SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server 'options' =&gt; [ // Set the SSL certificate and key paths for SSL support: 'ssl_cert_file' =&gt; 'path/to/ssl.crt', 'ssl_key_file' =&gt; 'path/to/ssl.key', // Whether or not the HTTP server should use coroutines; // enabled by default, and generally should not be disabled: 'enable_coroutine' =&gt; true, // Overwrite the default location of the pid file; // required when you want to run multiple instances of your service in different ports: 'pid_file' =&gt; 'path/to/pid_file.pid', ], // Since 2.1.0: Set the process name prefix. // The master process will be named `{prefix}-master`, // worker processes will be named `{prefix}-worker-{id}`, // and task worker processes will be named `{prefix}-task-worker-{id}` 'process-name' =&gt; 'your-app', ], ], ]; SSL support By default, Swoole is not compiled with SSL support. To enable SSL in Swoole, it must be configured with the --enable-openssl or --with-openssl-dir=/path/to/openssl option. Serving static files We support serving static files. By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Our static resource capabilities are fairly comprehensive; please see the chapter on static resources for full details on configuration.","title":"Introduction"},{"location":"v2/intro/#swoole","text":"Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel.","title":"Swoole"},{"location":"v2/intro/#install-swoole","text":"You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL .","title":"Install swoole"},{"location":"v2/intro/#install-mezzio-swoole","text":"To install this package, use Composer : $ composer require mezzio/mezzio-swoole","title":"Install mezzio-swoole"},{"location":"v2/intro/#swoole-with-mezzio","text":"mezzio-swoole enables an Mezzio application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/mezzio-swoole start This command will execute Swoole on localhost via port 8080 .","title":"Swoole with Mezzio"},{"location":"v2/logging/","text":"Logging Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400). Access Logs Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically. Formatting logs The Apache web server has long provided flexible and robust logging capabilities, and its formats are used across a variety of web servers and logging platforms. As such, we have chosen to use its formats for our standard implementation. However, we allow you to plug in your own system as needed. You can refer to the Apache mod_log_config documentation in order to understand the available placeholders available for format strings. Formatting is provided to the Psr3AccessLogDecorator via instances of the interface Mezzio\\Swoole\\Log\\AccessLogFormatterInterface : interface AccessLogFormatterInterface { public function format(AccessLogDataMap $map) : string; } AccessLogDataMap is a class used internally by the Psr3AccessLogDecorator in order to map Apache log placeholders to request/response values. Our default AccessLogFormatterInterface implementation, AccessLogFormatter , provides constants referencing the most common formats, but also allows you to use arbitrary log formats that use the standard Apache placeholders. The formats we include by default are: AccessLogFormatter::FORMAT_COMMON : Apache common log format: %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost: %v %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMBINED : Apache combined log format: %h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-Agent}i\" AccessLogFormatter::FORMAT_REFERER : %{Referer}i -&gt; %U AccessLogFormatter::FORMAT_AGENT : %{User-Agent}i AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %&gt;s %b'; AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format: %h %l %u %t “%r” %&gt;s %O ; AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format: %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i” ; AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost: %v:%p %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i\" ; Configuring a logger You may subsitute your own logger implementation into the Swoole request handler runner. Manual usage If you are manually instantiating a Mezzio\\Swoole\\SwooleRequestHandlerRunner instance, you may provide it as the seventh argument to the constructor: use Mezzio\\Swoole\\SwooleRequestHandlerRunner; $runner = new SwooleRequestHandlerRunner( $application, $serverRequestFactory, $serverRequestErrorResponseGenerator, $pidManager, $serverFactory, $staticResourceHandler, $logger // &lt;-- AccessLoggerInterface instance ); Container usage If you are using a PSR-11 container, the SwooleRequestHandlerRunnerFactory will retrieve a log instance using the Mezzio\\Swoole\\Log\\AccessLogInterface service. You have two options for substituting your own logger from there. First, if you already have a service which resolves to a Psr\\Log\\LoggerInterface instance, you can configure it by providing its name: 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'logger' =&gt; [ 'logger-name' =&gt; 'my_logger', // define the logger service name here ], ], ], If you don't want to manually provide the service name but you are okay with re-using your existing PSR-3 logger, the provided Mezzio\\Swoole\\Log\\AccessLogFactory will use the Psr\\Log\\LoggerInterface service to create a Psr3AccessLogDecorator instance. Since 2.4.0, the Mezzio\\Swoole\\Log\\AccessLogFactory will resolve the logger instance by using the Mezzio\\Swoole\\Log\\SwooleLogger service. If you were manually using this factory, you should register the service to the Mezzio\\Swoole\\Log\\SwooleLoggerFactory . This factory also allows you to specify a custom AccessLogFormatterInterface instance if you want. It will look up a service by the fully-qualified interface name, and use it if present. Otherwise, it creates an AccessLogFormatter instance for you. In both cases the factory will also look at the following configuration values: 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'logger' =&gt; [ 'format' =&gt; string, // one of the AccessLogFormatter::FORMAT_* // constants, or a custom format string 'use-hostname-lookups' =&gt; bool, // Set to true to enable hostname lookups ], ], ], Using Monolog as a PSR-3 logger When using Monolog with a StreamHandler , you must supply a file or a stream resource descriptor. We recommend using one of the following: php://stdout is a good choice, as this will generally write to the current console. php://stderr is also a good choice, as this will generally write to the current console, and allows you to filter based on that output stream. When using Docker , generally one of either /proc/1/fd/1 or /proc/1/fd/2 can be used, and are analogous to STDOUT and STDERR , respectively. We recommend using php://stdout and php://stderr instead, as these will be mapped to the correct locations by the language. ErrorLogHandler If you plan to write to STDERR , you might consider instead using the Monolog ErrorLogHandler , as this will use PHP's error_log() mechanism to write to the configured PHP error log. You can then either introspect that location, or configure the error_log php.ini setting to point to either /dev/stderr or, if on Docker, /proc/1/fd/2 . Additionally, we recommend using the PsrLogMessageProcessor with any Monolog handler to ensure that any templated parameters are expanded by the logger. As an example, the following is a factory that wires a StreamHandler to a Monolog\\Logger instance. use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use Monolog\\Processor\\PsrLogMessageProcessor; class LoggerFactory { public function __invoke(ContainerInterface $container) : LoggerInterface { $logger = new Logger('swoole-http-server'); $logger-&gt;pushHandler(new StreamHandler( 'php://stdout', Logger::INFO, $bubble = true, $expandNewLines = true )); $logger-&gt;pushProcessor(new PsrLogMessageProcessor()); return $logger; } } If you then wire this to the Psr\\Log\\LoggerInterface service, it will be used by Swoole for the purposes of access logs as well.","title":"Logging"},{"location":"v2/logging/#logging","text":"Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400).","title":"Logging"},{"location":"v2/logging/#access-logs","text":"Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically.","title":"Access Logs"},{"location":"v2/logging/#configuring-a-logger","text":"You may subsitute your own logger implementation into the Swoole request handler runner.","title":"Configuring a logger"},{"location":"v2/migration/","text":"Migration This document covers changes between version 1 and version 2, and how you may update your code to adapt to them. Controlling the server In version 1, you would execute the web server via the entry script, e.g.: $ php public/index.php start With version 2, we ship the command line tools for controlling your server via the binary mezzio-swoole : # Start the server: $ ./vendor/bin/mezzio-swoole start -d # Reload the server: $ ./vendor/bin/mezzio-swoole reload # Stop the server: $ ./vendor/bin/mezzio-swoole stop While you can still call php public/index.php , you cannot daemonize the server using that command, nor reload or stop it (other than using Ctrl-C ). You will need to change any deployment commands you currently use to consume the new command line tooling. Coroutine support In version 1, to enable Swoole's coroutine support, you were expected to pass a boolean true value to the mezzio-swoole.swoole-http-server.options.enable_coroutine flag. That flag now controls specifically the HTTP server coroutine support, and defaults to true . To set system-wide coroutine support, toggle the mezzio-swoole.enable_coroutine flag, which defaults to boolean false: return [ 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; false, // system-wide support 'swoole-http-server' =&gt; [ 'options' =&gt; [ 'enable_coroutine' =&gt; true, // HTTP server coroutine support ], ], ] ]; ServerFactory Version 2 refactors the architecture slightly to allow providing the HTTP server as a service, which allows us to enable async task workers . The primary changes to enable this are: Mezzio\\Swoole\\ServerFactory and its associated service was removed. Mezzio\\Swoole\\ServerFactoryFactory was removed. Mezzio\\Swoole\\HttpServerFactory was created. The service Swoole\\Http\\Server was added, pointing to Mezzio\\Swoole\\HttpServerFactory . The constructor for Mezzio\\Swoole\\SwooleRequestHandlerRunner was modified. Previously, the fifth argument was typehinted against the former ServerFactory ; it now typehints against Swoole\\Http\\Server . The factory for this class was modified to pass the correct service. These changes should only affect users who were providing service substitutions or extending the affected classes.","title":"Migration"},{"location":"v2/migration/#migration","text":"This document covers changes between version 1 and version 2, and how you may update your code to adapt to them.","title":"Migration"},{"location":"v2/migration/#controlling-the-server","text":"In version 1, you would execute the web server via the entry script, e.g.: $ php public/index.php start With version 2, we ship the command line tools for controlling your server via the binary mezzio-swoole : # Start the server: $ ./vendor/bin/mezzio-swoole start -d # Reload the server: $ ./vendor/bin/mezzio-swoole reload # Stop the server: $ ./vendor/bin/mezzio-swoole stop While you can still call php public/index.php , you cannot daemonize the server using that command, nor reload or stop it (other than using Ctrl-C ). You will need to change any deployment commands you currently use to consume the new command line tooling.","title":"Controlling the server"},{"location":"v2/migration/#coroutine-support","text":"In version 1, to enable Swoole's coroutine support, you were expected to pass a boolean true value to the mezzio-swoole.swoole-http-server.options.enable_coroutine flag. That flag now controls specifically the HTTP server coroutine support, and defaults to true . To set system-wide coroutine support, toggle the mezzio-swoole.enable_coroutine flag, which defaults to boolean false: return [ 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; false, // system-wide support 'swoole-http-server' =&gt; [ 'options' =&gt; [ 'enable_coroutine' =&gt; true, // HTTP server coroutine support ], ], ] ];","title":"Coroutine support"},{"location":"v2/migration/#serverfactory","text":"Version 2 refactors the architecture slightly to allow providing the HTTP server as a service, which allows us to enable async task workers . The primary changes to enable this are: Mezzio\\Swoole\\ServerFactory and its associated service was removed. Mezzio\\Swoole\\ServerFactoryFactory was removed. Mezzio\\Swoole\\HttpServerFactory was created. The service Swoole\\Http\\Server was added, pointing to Mezzio\\Swoole\\HttpServerFactory . The constructor for Mezzio\\Swoole\\SwooleRequestHandlerRunner was modified. Previously, the fifth argument was typehinted against the former ServerFactory ; it now typehints against Swoole\\Http\\Server . The factory for this class was modified to pass the correct service. These changes should only affect users who were providing service substitutions or extending the affected classes.","title":"ServerFactory"},{"location":"v2/static-resources/","text":"Static Resources One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Disabling static resources Since 2.1.0 If you want to disable serving of static resources, you can do so in two ways. If you have a custom factory for the SwooleRequestHandlerRunner , or are instantiating it manually, pass a null value for the sixth argument of its constructor. As an example, within a factory: use Psr\\Container\\ContainerInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Swoole\\Http\\Server as SwooleHttpServer; use Mezzio\\ApplicationPipeline; use Mezzio\\Swoole; function (ContainerInterface $container) : Swoole\\SwooleRequestHandlerRunner { return new SwooleRequestHandlerRunner( $container-&gt;get(ApplicationPipeline::class), $container-&gt;get(ServerRequestInterface::class), $container-&gt;get(Swoole\\ServerRequestErrorResponseGenerator::class), $container-&gt;get(Swoole\\PidManager::class), $container-&gt;get(SwooleHttpServer::class), null, // No static resource handler! $container-&gt;has(Swoole\\Log\\AccessLogInterface::class ? $container-&gt;get(Swool\\Log\\AccessLogInterface::class : null ); } If you are using the default factory provided ( Mezzio\\Swoole\\SwooleRequestHandlerRunnerFactory ), you can also disable the functionality via configuration. To do this, set the mezzio-swoole.swoole-http-server.static-files.enable flag to boolean false : return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'enable' =&gt; false, ], ], ], ]; Middleware The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers). Providing your own middleware If you want to disable middleware, or to provide an alternate list of middleware (including your own!), you will need to provide an alternate StaticResourceHandler factory. In most cases, you can extend StaticResourceHandlerFactory and override the configureMiddleware(array $config) : array method to do so. Be sure to remember to add a dependencies setting mapping the StaticResourceHandlerInterface service to your new factory when done! Configuration We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' =&gt; true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ]; Security warning Never add php as an allowed static file extension, as doing so could expose the source code of your PHP application! Document root If no document_root configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root does not exist, we raise an exception. Default extension/content-types By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Configuration Example The example which follows provides the following options: Sets the document root to /var/www/htdocs . Adds a custom extension / content-type map. Provides a clearstatcache interval of 2 hours. Selects the \"strong\" ETag algorithm. Indicates a gzip compression level of 3. Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files. Sets Cache-Control directives for plain text files. // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'enable' =&gt; true, 'document-root' =&gt; '/var/www/htdocs', 'type-map' =&gt; [ 'css' =&gt; 'text/css', 'gif' =&gt; 'image/gif', 'ico' =&gt; 'image/x-icon', 'jpg' =&gt; 'image/jpg', 'jpeg' =&gt; 'image/jpg', 'js' =&gt; 'application/javascript', 'png' =&gt; 'image/png', 'svg' =&gt; 'image/svg+xml', 'txt' =&gt; 'text/plain', ], 'clearstatcache-interval' =&gt; 7200, 'etag-type' =&gt; 'strong', 'gzip' =&gt; [ 'level' =&gt; 3, ], 'directives' =&gt; [ '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-transform', ], 'last-modified' =&gt; true, 'etag' =&gt; true, ], '/\\.txt$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-cache', ], ], ], ], ], ], ]; Writing Middleware Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() . Providing an alternative mechanism for sending response content In some cases, you may want to alter how the Swoole\\Http\\Response receives the body content. By default, we use Swoole\\Http\\Response::sendfile() . However, this may not work well when performing tasks such as compression, appending a watermark, etc. As an example, the GzipMiddleware adds a compression filter to a filehandle representing the file to send, and then calls Swoole\\Http\\Response::write() in a loop until all content is sent. To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback() method as detailed in the section above within your middleware. Alternative static resource handlers As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration. Example alternate static resource handler: StaticMappedResourceHandler Since 2.7.0 The default static resource handler, Mezzio\\Swoole\\StaticResourceHandler , requires all files to be in the specified document root directory (by default, \"public\") when instantiating the handler. If you are using modules generating templates with associated file assets (JavaScript, CSS, etc.), those files must be copied to the \"public\" directory if you wish to allow access to them. This can be done via scripting, but is one more step to consider when testing or deploying a site. Ideally, a module should be able to contain both its template and any dependencies that template relies upon. For example, assume you have a module, AwesomeModule, with a handler called \"HomeHandler\", which renders the 'home' template. You designate the prefix, /awesome-home for rendering the assets. The structure of your module files looks like this: AwesomeModule ├── src | ├── Handler | | ├── HomeHandler.php | | ├── HomeHandlerFactory.php | ├── ConfigProvider.php ├── templates │ ├── home | | ├── home.html | | ├── style.css │ ├── layouts In your home.html template, you can refer to the style.css file, using /awesome-home as follows: &lt;link href=\"/awesome-home/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; Currently, however, this will cause errors, as the stylesheet will not be available under the public/ tree of the application. You would need to copy or symlink the files to the appropriate location to make that work. The StaticMappedResourceHandler solves this problem. Using StaticMappedResourceHandler To use Mezzio\\Swoole\\StaticMappedResourceHandler from an application or module: Define what your URI prefix will be (e.g., /awesome-home ). Update references to linkable resources in your templates to use the desired prefix (e.g., &lt;script src='/awesome-home/style.css'&gt;&lt;/script&gt; ). In your application/module configuration (or ConfigProvider ), add the relationship between your prefix ( awesome-home ) and any directories containing the assets. In the application's configuration, set the alias of Mezzio\\Swoole\\StaticResourceHandlerInterface to use Mezzio\\Swoole\\StaticMappedResourceHandler . For step #3, in your module's ConfigProvider, you can add a configuration setting as follows: public function __invoke() : array { return [ 'config' =&gt; [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'mapped-document-roots' =&gt; [ 'awesome-home' =&gt; __DIR__ . '/../../templates/home' ] ] ] ] ] ]; } Note that prefixes are always the first part after the host, and specifying the initial slash is optional (i.e. awsesome-home and /awesome-home both work and represent the same thing). In step #4, in your application's configuration ( autoload/dependencies.global.php is a good place), override the default implementation of StaticResourceHandlerInterface : return [ 'dependencies' =&gt; [ 'aliases' =&gt; [ Mezzio\\Swoole\\StaticResourceHandlerInterface::class =&gt; Mezzio\\Swoole\\StaticMappedResourceHandler::class // Fully\\Qualified\\ClassOrInterfaceName::class =&gt; Fully\\Qualified\\ClassName::class, ], // etc. For step #3, an alternative to storing a configuration is dynamically associating /awesome-home to a directory in code (probably within a factory). This approach could be useful if the directory of the assets isn't know until runtime. use Psr\\Container\\ContainerInterface; use Mezzio\\Template\\TemplateRendererInterface; use Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface; class AwesomeHomeHandlerFactory { public function __invoke(ContainerInterface $container) : DocumentationViewHandler { // Establish location for the home template assets $repo = $container-&gt;get(FileLocationRepositoryInterface::class); $repo-&gt;addMappedDocumentRoot( 'awesome-home', realpath(__DIR__ . '/../../templates/home') ); return new AwesomeHomeHandler( $container-&gt;get(TemplateRendererInterface::class) ); } } When the template renders, the client will request /awesome-home/style.css , which the StaticMappedResourceHandler will now retrieve from the templates/home/ folder of the module. Mezzio\\Swoole\\StaticMappedResourceHandler uses the Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepository (which implements Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface ) to maintain an association of URI prefixes with file directories. If you require using a file location that requires authentication, decompression, etc. you can override the default functionality by creating your own implementation of Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface .","title":"Static Resources"},{"location":"v2/static-resources/#static-resources","text":"One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it.","title":"Static Resources"},{"location":"v2/static-resources/#middleware","text":"The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers).","title":"Middleware"},{"location":"v2/static-resources/#configuration","text":"We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' =&gt; true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ];","title":"Configuration"},{"location":"v2/static-resources/#writing-middleware","text":"Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() .","title":"Writing Middleware"},{"location":"v2/static-resources/#alternative-static-resource-handlers","text":"As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Alternative static resource handlers"},{"location":"v2/static-resources/#example-alternate-static-resource-handler-staticmappedresourcehandler","text":"Since 2.7.0 The default static resource handler, Mezzio\\Swoole\\StaticResourceHandler , requires all files to be in the specified document root directory (by default, \"public\") when instantiating the handler. If you are using modules generating templates with associated file assets (JavaScript, CSS, etc.), those files must be copied to the \"public\" directory if you wish to allow access to them. This can be done via scripting, but is one more step to consider when testing or deploying a site. Ideally, a module should be able to contain both its template and any dependencies that template relies upon. For example, assume you have a module, AwesomeModule, with a handler called \"HomeHandler\", which renders the 'home' template. You designate the prefix, /awesome-home for rendering the assets. The structure of your module files looks like this: AwesomeModule ├── src | ├── Handler | | ├── HomeHandler.php | | ├── HomeHandlerFactory.php | ├── ConfigProvider.php ├── templates │ ├── home | | ├── home.html | | ├── style.css │ ├── layouts In your home.html template, you can refer to the style.css file, using /awesome-home as follows: &lt;link href=\"/awesome-home/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; Currently, however, this will cause errors, as the stylesheet will not be available under the public/ tree of the application. You would need to copy or symlink the files to the appropriate location to make that work. The StaticMappedResourceHandler solves this problem.","title":"Example alternate static resource handler: StaticMappedResourceHandler"},{"location":"v2/table/","text":"Using Swoole Tables in Your Application Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor. Initialize the Table Within the Constructor You must call your table's create() method, and this must be done prior to initializing any worker processes; if you fail to do so, your table will not work. We recommend doing this in your table class's constructor. Creating a Table As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this-&gt;column('x', self::TYPE_FLOAT); $this-&gt;column('y', self::TYPE_FLOAT); $this-&gt;column('z', self::TYPE_FLOAT); $this-&gt;create(); } } Creating Your Table Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' =&gt; [ // ... Vector3dTable::class =&gt; new Vector3dTable(), ], ]; } Using the Table Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container-&gt;get(Vector3dTable::class) (to use our previous example). Troubleshooting If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table-&gt;create() in your custom table's constructor.","title":"Using Swoole Tables"},{"location":"v2/table/#using-swoole-tables-in-your-application","text":"Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor.","title":"Using Swoole Tables in Your Application"},{"location":"v2/table/#creating-a-table","text":"As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this-&gt;column('x', self::TYPE_FLOAT); $this-&gt;column('y', self::TYPE_FLOAT); $this-&gt;column('z', self::TYPE_FLOAT); $this-&gt;create(); } }","title":"Creating a Table"},{"location":"v2/table/#creating-your-table","text":"Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' =&gt; [ // ... Vector3dTable::class =&gt; new Vector3dTable(), ], ]; }","title":"Creating Your Table"},{"location":"v2/table/#using-the-table","text":"Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container-&gt;get(Vector3dTable::class) (to use our previous example).","title":"Using the Table"},{"location":"v2/table/#troubleshooting","text":"If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table-&gt;create() in your custom table's constructor.","title":"Troubleshooting"},{"location":"v3/async-tasks/","text":"Triggering Async Tasks Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes — allowing your application to continue responding to requests while the server processes your task. Configuring the Server Process for Tasks In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they trigger, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute in the order they are queued. 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; true, //optional to enable coroutines and useful for tasks coroutines 'swoole-http-server' =&gt; [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 8080, 'options' =&gt; [ 'worker_num' =&gt; 4, // The number of HTTP Server Workers 'task_worker_num' =&gt; 4, // The number of Task Workers 'task_enable_coroutine' =&gt; true, // optional to turn on task coroutine support ], ], ]; CLI options for worker_num and task_worker_num Each of the worker_num and task_worker_num options have corresponding options in the mezzio:swoole:start and mezzio:swoole:reload console commands: --num-workers|-w can be used to specify the number of HTTP Server Workers --num-task-workers|-t can be used to specify the number of Task Workers Task Events Mezzio\\Swoole\\SwooleRequestHandlerRunner registers listeners on the Swoole\\Http\\Server \"task\" and \"finish\" events. \"task\" is triggered when $server-&gt;task() is called, and \"finish\" is triggered when a task worker calls $trigger-&gt;finish() . Each of the listeners that SwooleRequestHandlerRunner registers in turn dispatch an event via its composed PSR-14 event dispatcher : Mezzio\\Swoole\\Event\\TaskEvent is dispatched via the \"task\" listener. Mezzio\\Swoole\\Event\\TaskFinishEvent is dispatched via the \"finish\" listener. Registering Task Listeners Registering listeners is the same as for other events: you will specify one or more of the above event types, pointing to a list of listeners that are defined as services in your container: // in config/autoload/mezzio.global.php: use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\TaskEvent::class =&gt; [ Your\\TaskLoggerListener::class, Your\\TaskEventListener::class, ], ], ], ], ]; TaskFinishEvent listener not required The \"finish\" event primarily exists to allow you to know when a given task has completed processing. In most cases, you can have a single listener that logs completion of the given task ID, ignoring the return value. Shipped task listeners This package ships two listeners that you can use to process tasks: Mezzio\\Swoole\\Task\\TaskEventDispatchListener and Mezzio\\Task\\TaskInvokerListener . TaskEventDispatchListener Mezzio\\Swoole\\Task\\TaskEventDispatchListener composes a PSR-14 event dispatcher and a PSR-3 logger instance. When invoked, it retrieves the data from the TaskEvent (via TaskEvent::getData() ). If that data is not an object, it does nothing. Otherwise, it treats it as an event, passing it to the composed event dispatcher, and setting the TaskEvent 's return value to the event returned by the dispatcher. Once complete, it marks task processing as complete on the event. To register this listener, use the following configuration: // in config/autoload/mezzio.global.php: use Mezzio\\Swoole\\Event; use Mezzio\\Swoole\\Task\\TaskEventDispatchListener; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\TaskEvent::class =&gt; [ TaskEventDispatchListener::class, ], ], ], ], ]; TaskInvokerListener Mezzio\\Swoole\\Task\\TaskInvokerListener works with a suite of other classes to allow processing task data. It composes a PSR-11 container and a PSR-3 logger instance. When invoked, it pulls the data from the TaskEvent (via TaskEvent::getData() ); if the data does not implement Mezzio\\Swoole\\Task\\TaskInterface , it does nothing and returns immediately. Otherwise, it invokes the task instance, passing it the PSR-11 container as the sole argument. When done, it marks task processing complete in the TaskEvent . The TaskInterface has the following definition: namespace Mezzio\\Swoole\\Task; use JsonSerializable; use Psr\\Container\\ContainerInterface; interface TaskInterface extends JsonSerializable { /** * @return mixed */ public function __invoke(ContainerInterface $container); } The idea is that you can initialize a task as follows: $server-&gt;task(new Task( function ($data) { // process the data }, $data )); And then the TaskInvokerListener will intercept it, identify a task instance, and invoke it in order to process it. To make this work, the package ships two TaskInterface implementations. The first is Mezzio\\Swoole\\Task\\Task , which composes the code that will process the task data, and the task data itself (as the \"payload\"): namespace Mezzio\\Swoole\\Task; use Psr\\Container\\ContainerInterface; final class Task implements TaskInterface { /** @var callable */ private $handler; private array $payload; public function __construct(callable $handler, ...$payload) { $this-&gt;handler = $handler; $this-&gt;payload = $payload; } /** * Container argument ignored in this implementation. */ public function __invoke(ContainerInterface $container) { return ($this-&gt;handler)(...$this-&gt;payload); } // serialization details intentionally left out of listing } This works exactly like the prior example: instantiate the Task with the handler and any data it should process. However, this task implementation has one caveat: the $handler MUST be serializable, and NOT contain references to other objects or resources (such as a database connection). The reason is because the Task instance is serialized and sent to another process completely, where it is then deserialized. To solve this limitation, the second implementation, Mezzio\\Swoole\\Task\\ServiceBasedTask , composes a service name and the task data to process. During invocation, it pulls the service from the supplied container instance, and then uses the service to process the task: namespace Mezzio\\Swoole\\Task; use Psr\\Container\\ContainerInterface; final class ServiceBasedTask implements TaskInterface { private array $payload; private string $serviceName; public function __construct(string $serviceName, ...$payload) { $this-&gt;serviceName = $serviceName; $this-&gt;payload = $payload; } public function __invoke(ContainerInterface $container) : void { $deferred = $container-&gt;get($this-&gt;serviceName); $listener = $deferred instanceof DeferredServiceListener ? $deferred-&gt;getListener() : $deferred; $listener(...$this-&gt;payload); } // serialization details intentionally left out of listing } What is the DeferredServiceListener ? It's a decorator for an invokable handler, generally a PSR-14 event listener. The idea behind the class is to allow dispatching events normally via a PSR-14 event dispatcher in your code, but having the listener queue a task that it then processes itself. To better understand the idea, let's look at the DeferredServiceListener : namespace Mezzio\\Swoole\\Task; use Swoole\\Http\\Server as SwooleHttpServer; final class DeferredServiceListener { private SwooleHttpServer $server; /** @var callable */ private $listener; private string $serviceName; public function __construct(SwooleHttpServer $server, callable $listener, string $serviceName) { $this-&gt;server = $server; $this-&gt;listener = $listener; $this-&gt;serviceName = $serviceName; } public function __invoke(object $event) : void { $this-&gt;server-&gt;task(new ServiceBasedTask($this-&gt;serviceName, $event)); } public function getListener(): callable { return $this-&gt;listener; } } In your configuration, you will use the Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator to decorate your event listener using the above class: // In config/autoload/dependencies.global.php: use Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator; return [ 'dependences' =&gt; [ 'factories' =&gt; [ App\\Listener\\UserCreationListener::class =&gt; App\\Listener\\UserCreationListenerFactory::class, ], 'delegators' =&gt; [ App\\Listener\\UserCreationListener::class =&gt; [ DeferredServiceListenerDelegator::class, ], ], ], ]; You would attach your listener as needed for your listener provider implementation, pulling the listener from the container: use App\\Event\\UserCreationEvent; use App\\Listener\\UserCreationListener; // Example where $listenerProvider is a Psr\\EventDispatcher\\ListenerProviderInterface // implementation, and defines a `listen()` method, and $container is a PSR-11 // container implementation: $listenerProvider = $factory(); $listenerProvider-&gt;listen(UserCreationEvent::class, $container-&gt;get(UserCreationListener::class)); Somewhere in your code, you might then dispatch the UserCreationEvent : use App\\Event\\UserCreationEvent; $dispatcher-&gt;dispatch(new UserCreationEvent($someData)); At this point, since the listener is decorated in a DeferredServiceListener instance, it queues a ServiceBasedTask . When the task worker goes to invoke the ServiceBasedTask , it pulls the service from the container... which ends up decorating it as a DeferredServiceListener again. To prevent infinite recursion, where the listener keeps queueing tasks for itself, the ServiceBasedTask checks to see if we have a DeferredServiceListener , and, if so, retrieves the actual listener it decorates from it. While this approach may seem convoluted, what it enables is the use of other services from your DI container when processing the task, including databases, caching, logging, and more. On top of that, it allows you to remove any references in your code to the Swoole HTTP server instance, isolating your code from the details of how the code actually executes behind a PSR-14 event dispatcher. This is the recommended way to queue and process tasks with mezzio-swoole. Examples Manually Triggering Tasks in Handlers Manually triggering tasks is not recommended, as it couples your application to Swoole, preventing usage in non-async paradigms as well as alternate async contexts. It can also make testing your application more difficult. We recommend the approach described in the section \"Dispatching a ServiceBasedTask via a PSR-14 Event Dispatcher\" . If you want to manually dispatch a task, you will need to: Compose the Swoole\\Http\\Server instance in your class. Call that instance's task() method with the data representing the task. As an example, we will create a request handler that composes the HTTP server instance. namespace Example; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Swoole\\Http\\Server as HttpServer; class TaskTriggeringHandler implements RequestHandlerInterface { /** @var ResponseFactoryInterface */ private $responseFactory; /** @var HttpServer */ private $server; public function __construct( HttpServer $server, ResponseFactoryInterface $responseFactory ) { $this-&gt;server = $server; $this-&gt;responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // Gather data from request $data = $request-&gt;getParsedBody(); // task() returns a task identifier, if you want to use it; otherwise, // you can ignore the return value. $taskIdentifier = $this-&gt;server-&gt;task([ 'to' =&gt; $data['email'], 'subject' =&gt; $data['subject'], 'message' =&gt; $data['message'], ]); // The task() method is asynchronous, so execution continues immediately. return $this-&gt;responseFactory()-&gt;createResponse(); } } Your handler will require a factory: namespace Example; use Psr\\Container\\ContainerInterface; use Psr\\Http\\Message\\ResponseFactoryInterface; use Swoole\\Http\\Server as HttpServer; class TaskTriggeringHandlerFactory { public function __invoke(ContainerInterface $container): TaskTriggeringHandler { return new TaskTriggeringHandler( $container-&gt;get(HttpServer::class), $container-&gt;get(ResponseFactoryInterface::class) ); } } And you will then need to notify the container configuration: // in config/autoload/global.php or similar: use Example\\TaskTriggeringHandler; use Example\\TaskTriggeringHandlerFactory; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ TaskTriggeringHandler::class =&gt; TaskTriggeringHandlerFactory::class, ], ], ]; Logging TaskEvent listener The following listener will listen to a TaskEvent , and log the information using the syslog. namespace Example; use Mezzio\\Swoole\\Event\\TaskEvent; use function date; use function sprintf; use function syslog; use function var_dump; use const LOG_INFO; class LoggingListener { public function __invoke(TaskEvent $event): void { syslog(LOG_INFO, sprintf( '[%s] [%d] %s', date('c'), $event-&gt;getTaskId(), var_dump($event-&gt;getData()) )); } } You would configure the application to use the listener as follows: // in config/autoload/swoole.global.php or similar: use Example\\LoggingListener; use Mezzio\\Swoole\\Event\\TaskEvent; return [ 'dependencies' =&gt; [ 'invokables' =&gt; [ LoggingListener::class =&gt; LoggingListener::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskEvent::class =&gt; [ LoggingListener::class, ], ], ], ], ]; To trigger the event, you will create a task using a Swoole\\Http\\Server instance: $server-&gt;task($data); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Logging TaskFinishEvent listener The following listener will listen to a TaskFinishEvent , and log the return value using the syslog. It looks almost identical to the previous example. namespace Example; use Mezzio\\Swoole\\Event\\TaskFinishEvent; use function date; use function sprintf; use function syslog; use function var_dump; use const LOG_INFO; class TaskCompletionLoggingListener { public function __invoke(TaskFinishEvent $event): void { syslog(LOG_INFO, sprintf( '[%s] [%d] %s', date('c'), $event-&gt;getTaskId(), var_dump($event-&gt;getReturnValue()) )); } } Similar to the previous example, you would configure the application to use the listener as follows: // in config/autoload/swoole.global.php or similar: use Example\\TaskCompletionLoggingListener; use Mezzio\\Swoole\\Event\\TaskFinishEvent; return [ 'dependencies' =&gt; [ 'invokables' =&gt; [ TaskCompletionLoggingListener::class =&gt; TaskCompletionLoggingListener::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskFinishEvent::class =&gt; [ TaskCompletionLoggingListener::class, ], ], ], ], ]; Unlike the previous example, however, you do not need to trigger this event yourself; it gets triggered by the SwooleRequestHandlerRunner . Queueing task data for the TaskEventDispatchListener In this example, we will configure the TaskEventDispatchListener as a TaskEvent listener. The TaskEventDispatchListener will in turn have a listener attached for a custom event, SomeDeferrableTask . We will queue a SomeDeferrableTask instance via the Swoole HTTP server task() method to defer its execution to the custom listener we create. First, we will create the custom task type: namespace Example; class SomeDeferrableTask { } Next, we will create a listener for this event type: namespace Example; class SomeDeferrableTaskListener { public function __invoke(SomeDeferrableTask $event): void { // process the task here } } Next, we will configure listeners for the TaskEvent and our custom SomeDeferrableTask : // in config/autoload/swoole.global.php or similar: use Example\\SomeDeferrableTask; use Example\\SomeDeferrableTaskListener; use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Event\\TaskEventDispatchListener; return [ 'dependencies' =&gt; [ 'invokables' =&gt; [ SomeDeferrableTaskListener::class =&gt; SomeDeferrableTaskListener::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ SomeDeferrableTask::class =&gt; [ SomeDeferrableTaskListener::class, ], TaskEvent::class =&gt; [ TaskEventDispatchListener::class, ], ], ], ], ]; To trigger the event, you will create a task using a Swoole\\Http\\Server instance: $server-&gt;task(new SomeDeferrableTask()); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Queueing a Task for the TaskInvokerListener In this example, we register the TaskInvokerListener with the TaskEvent . We then create a Mezzio\\Swoole\\Task\\Task instance and use the Swoole HTTP server to queue the task. First, we will configure the TaskInvokerListener for the TaskEvent : // in config/autoload/swoole.global.php or similar: use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Event\\TaskInvokerListener; return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskEvent::class =&gt; [ TaskInvokerListener::class, ], ], ], ], ]; Next, we will create a Task instance. The constructor for Mezzio\\Swoole\\Task\\Task expects a callable listener as the first argument, and then zero or more additional arguments representing the arguments to pass to the listener. use Mezzio\\Swoole\\Task\\Task; $task = new Task( static function(object $event): void { // Process the $event object }, (object) [ 'message' =&gt; 'hello world', ] ); Finally, we will enqueue the task using a Swoole\\Http\\Server instance: $server-&gt;task($task); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Queueing a ServiceBasedTask for the TaskInvokerListener In this example, we'll create a listener class that can handle a specific event type. We will create a factory for the listener, and register it in the DI container. We will also register the TaskInvokerListener with the TaskEvent . Finally, we will then create a Mezzio\\Swoole\\Task\\ServiceBasedTask instance using the service name for our listener and an instance of the event type it expects, and use the Swoole HTTP server to queue the task. First, let's define an event type: namespace Example; class SomeDeferrableEvent { /** @var string */ private $message; public function __construct(string $message) { $this-&gt;message = $message; } public function __toString(): string { return $this-&gt;message; } } Next, we will create a listener for this event type: namespace Example; use Psr\\Log\\LoggerInterface; class SomeDeferrableEventListener { /** @var LoggerInterface */ private $logger; public function __construct(LoggerInterface $logger) { $this-&gt;logger = $logger; } public function __invoke(SomeDeferrableEvent $event): void { $this-&gt;logger-&gt;info(sprintf('Message: %s', (string) $event)); } } The listener will require a factory: namespace Example; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; class SomeDeferrableEventListenerFactory { public function __invoke(ContainerInterface $container): SomeDeferrableEventListener { return new SomeDeferrableEventListener( $container-&gt;get(LoggerInterface::class) ); } } At this point, we turn to configuration. We will add dependency configuration for our listener (omitting the configuration for the logger service; we will assume you have done so already, or can figure out how to do so). We will also add configuration to bind the TaskInvokerListener to the TaskEvent . // in config/autoload/swoole.global.php or similar: use Example\\SomeDeferrableEventListener; use Example\\SomeDeferrableEventListenerFactory; use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Event\\TaskInvokerListener; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ SomeDeferrableEventListener::class =&gt; SomeDeferrableEventListenerFactory::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskEvent::class =&gt; [ TaskInvokerListener::class, ], ], ], ], ]; Next, we will create a ServiceBasedTask instance. The constructor for Mezzio\\Swoole\\Task\\Task expects the name of a service that can be pulled from the application DI container as the first argument, and then zero or more additional arguments representing the arguments to pass to the listener. The service is expected to be invokable (i.e., it MUST define the method __invoke() ). use Example\\SomeDeferrableEvent; use Example\\SomeDeferrableEventListener; use Mezzio\\Swoole\\Task\\ServiceBasedTask; $task = new ServiceBasedTask( SomeDeferrableEventListener::class, new SomeDeferrableEvent('hello world') ); Finally, we will enqueue the task using a Swoole\\Http\\Server instance: $server-&gt;task($task); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Dispatching a ServiceBasedTask via a PSR-14 Event Dispatcher This final example builds on the previous. We will use the same event and listener. However, instead of queueing the task via the Swoole HTTP server, we will queue it via a PSR-14 event dispatcher. To make that possible, we will add a delegator factory for our listener that will do the work of queueing the task for us. This example will make the assumption that you are using the same PSR-14 event dispatcher with both the SwooleRequestHandlerRunner and the rest of your application, and will re-purpose the Mezzio\\Swoole\\Event\\SwooleListenerProvider to also handle listeners for our Example\\SomeDeferrableEvent . First, we will define a handler that triggers this event: namespace Example; use Psr\\EventDispatcher\\EventDispatcherInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class MessageHandler implements RequestHandlerInterface { /** @var EventDispatcherInterface */ private $dispatcher; /** @var ResponseFactoryInterface */ private $responseFactory; public function __construct( EventDispatcherInterface $dispatcher, ResponseFactoryInterface $responseFactory ) { $this-&gt;dispatcher = $dispatcher; $this-&gt;responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request): ResponseInterface { $this-&gt;dispatcher-&gt;dispatch(new SomeDeferrableEvent('hello world')); return $this-&gt;responseFactory-&gt;createResponse(); } } This handler will need a factory. namespace Example; use Psr\\Container\\ContaienrInterface; use Psr\\EventDispatcher\\EventDispatcherInterface; use Psr\\Http\\Message\\ResponseFactoryInterface; class MessageHandlerFactory { public function __invoke(ContainerInterface $container): MessageHandler { return new MessageHandler( $container-&gt;get(EventDispatcherInterface::class), $container-&gt;get(ResponseFactoryInterface::class) ); } } The next step is changing configuration. We need to configure our container to tell it about our handler, as well as to add the Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator as a delegator factory for our Example\\SomeDeferrableEventListener . We will also add configuration to map our listener to our custom event. // in config/autoload/swoole.global.php or similar: use Example\\MessageHandler; use Example\\MessageHandlerFactory; use Example\\SomeDeferrableEvent; use Example\\SomeDeferrableEventListener; use Example\\SomeDeferrableEventListenerFactory; use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Event\\TaskInvokerListener; use Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ MessageHandler::class =&gt; MessageHandlerFactory::class, SomeDeferrableEventListener::class =&gt; SomeDeferrableEventListenerFactory::class, ], 'delegators' =&gt; [ SomeDeferrableEventListener::class =&gt; [ DeferredServiceListenerDelegator::class, ], ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ SomeDeferrableEvent::class =&gt; [ SomeDeferrableEventListener::class, ], TaskEvent::class =&gt; [ TaskInvokerListener::class, ], ], ], ], ]; At this point, we are done. When the handler dispatches the event, our listener is notified. However, the listener is decoreated via the DeferredServiceListenerDelegator , which will itself enqueue a ServiceBasedTask in the Swoole HTTP server, using the listener's service name and the event passed to the listener. The TaskInvokerListener then passes the container to the task, which pulls our listener and executes it with the event.","title":"Async Tasks"},{"location":"v3/async-tasks/#triggering-async-tasks","text":"Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes — allowing your application to continue responding to requests while the server processes your task.","title":"Triggering Async Tasks"},{"location":"v3/async-tasks/#configuring-the-server-process-for-tasks","text":"In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they trigger, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute in the order they are queued. 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; true, //optional to enable coroutines and useful for tasks coroutines 'swoole-http-server' =&gt; [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 8080, 'options' =&gt; [ 'worker_num' =&gt; 4, // The number of HTTP Server Workers 'task_worker_num' =&gt; 4, // The number of Task Workers 'task_enable_coroutine' =&gt; true, // optional to turn on task coroutine support ], ], ];","title":"Configuring the Server Process for Tasks"},{"location":"v3/async-tasks/#task-events","text":"Mezzio\\Swoole\\SwooleRequestHandlerRunner registers listeners on the Swoole\\Http\\Server \"task\" and \"finish\" events. \"task\" is triggered when $server-&gt;task() is called, and \"finish\" is triggered when a task worker calls $trigger-&gt;finish() . Each of the listeners that SwooleRequestHandlerRunner registers in turn dispatch an event via its composed PSR-14 event dispatcher : Mezzio\\Swoole\\Event\\TaskEvent is dispatched via the \"task\" listener. Mezzio\\Swoole\\Event\\TaskFinishEvent is dispatched via the \"finish\" listener.","title":"Task Events"},{"location":"v3/async-tasks/#registering-task-listeners","text":"Registering listeners is the same as for other events: you will specify one or more of the above event types, pointing to a list of listeners that are defined as services in your container: // in config/autoload/mezzio.global.php: use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\TaskEvent::class =&gt; [ Your\\TaskLoggerListener::class, Your\\TaskEventListener::class, ], ], ], ], ];","title":"Registering Task Listeners"},{"location":"v3/async-tasks/#shipped-task-listeners","text":"This package ships two listeners that you can use to process tasks: Mezzio\\Swoole\\Task\\TaskEventDispatchListener and Mezzio\\Task\\TaskInvokerListener .","title":"Shipped task listeners"},{"location":"v3/async-tasks/#examples","text":"","title":"Examples"},{"location":"v3/command-line/","text":"Command Line Tooling This package provides integration with laminas-cli , and provides the following commands: mezzio:swoole:start to start the server mezzio:swoole:stop to stop the server (when run in daemonized mode) mezzio:swoole:reload to reload the server (when run in daemonized mode) mezzio:swoole:status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/laminas help mezzio:swoole:start The mezzio:swoole:stop , mezzio:swoole:status , and mezzio:swoole:reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The mezzio:swoole:start command, however, may need customizations if you have customized your application bootstrap. The mezzio:swoole:start command The mezzio:swoole:start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), the number of task workers to spawn (provided via the --num-task-workers or -t option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Mezzio\\Application and Mezzio\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Mezzio skeleton application. Writing a custom mezzio:swoole:start command If your application needs alternate bootstrapping (e.g., if you have modified the public/index.php , or if you are using this package with a different middleware runtime), we recommend writing a custom mezzio:swoole:start command. As an example, let's say you have altered your application such that you're defining your routes in multiple files, and instead of: (require 'config/routes.php')($app, $factory, $container); you instead have something like: $handle = opendir('config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } You could write a command such as the following: // In src/App/Command/StartCommand.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; use Swoole\\Http\\Server as SwooleHttpServer; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; use Mezzio\\Application; use Mezzio\\MiddlewareFactory; use Mezzio\\Swoole\\Command\\StartCommand as BaseStartCommand; use Mezzio\\Swoole\\PidManager; class StartCommand extends BaseStartCommand { protected function execute(InputInterface $input, OutputInterface $output) : int { // This functionality is identical to the base start command, and should // be copy and pasted to your implementation: $this-&gt;pidManager = $this-&gt;container-&gt;get(PidManager::class); if ($this-&gt;isRunning()) { $output-&gt;writeln('&lt;error&gt;Server is already running!&lt;/error&gt;'); return 1; } $server = $this-&gt;container-&gt;get(SwooleHttpServer::class); $server-&gt;set([ 'daemonize' =&gt; $input-&gt;getOption('daemonize'), 'worker_num' =&gt; $input-&gt;getOption('num-workers') ?? self::DEFAULT_NUM_WORKERS, ]); /** @var \\Mezzio\\Application $app */ $app = $this-&gt;container-&gt;get(Application::class); /** @var \\Mezzio\\MiddlewareFactory $factory */ $factory = $this-&gt;container-&gt;get(MiddlewareFactory::class); // Execute programmatic/declarative middleware pipeline and routing // configuration statements (require 'config/pipeline.php')($app, $factory, $this-&gt;container); // // This is the new code from above: // $handle = opendir(getcwd() . '/config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } // And now we return to the original code: // Run the application $app-&gt;run(); return 0; } } You will also need to write a factory for the class: // In src/App/Command/StartCommandFactory.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; class StartCommandFactory { public function __invoke(ContainerInterface $container) : StartCommand { return new StartCommand($container); } } If this is all you're changing, you can map this new command to the existing Mezzio\\Swoole\\Command\\StartCommand service within your configuration: // in config/autoload/dependencies.global.php: use App\\Command\\StartCommandFactory; use Mezzio\\Swoole\\Command\\StartCommand; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ StartCommand::class =&gt; StartCommandFactory::class, ], ], ]; Since the laminas binary uses your application configuration and container, this will substitute your command for the shipped command!","title":"Command Line Tooling"},{"location":"v3/command-line/#command-line-tooling","text":"This package provides integration with laminas-cli , and provides the following commands: mezzio:swoole:start to start the server mezzio:swoole:stop to stop the server (when run in daemonized mode) mezzio:swoole:reload to reload the server (when run in daemonized mode) mezzio:swoole:status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/laminas help mezzio:swoole:start The mezzio:swoole:stop , mezzio:swoole:status , and mezzio:swoole:reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The mezzio:swoole:start command, however, may need customizations if you have customized your application bootstrap.","title":"Command Line Tooling"},{"location":"v3/command-line/#the-mezzioswoolestart-command","text":"The mezzio:swoole:start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), the number of task workers to spawn (provided via the --num-task-workers or -t option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Mezzio\\Application and Mezzio\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Mezzio skeleton application.","title":"The mezzio:swoole:start command"},{"location":"v3/considerations/","text":"Considerations when using Swoole Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application. Long-running processes When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead. PDO Coroutine Support Please be aware that enabling coroutine support with Swoole\\Runtime::enableCoroutine() only decorates MySql PDO connections with coroutines; other drivers (e.g., pdo_pgsql) remain blocking as of Swoole 4.1.2. For more details, visit the related bug report on the Swoole issue tracker . Sessions Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives. mezzio-session-cache mezzio-session-cache provides a persistence adapter for mezzio-session that uses a PSR-6 CacheItemPoolInterface implementation for storing and retrieving sessions. This approach requires that you setup a backend cache storage for your session data. psr7-sessions/storageless PSR7Session provides session middleware that uses JWT tokens within the session cookie to transmit session data between the server and client. This approach requires no central session storage, but does impose limits on the amount of information you can store in a session. Stateless services The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail. Decoration If a service implements an interface, you can decorate the service to make it stateless. Well-written interfaces will be stateless by design, and not provide methods meant to internally change state. In these situations, you can create a proxy class that decorates the original service: class ProxyService implements OriginalInterface { /** @var OriginalInterface */ private $proxy; public function __construct(OriginalInterface $proxy) { $this-&gt;proxy = $proxy; } public function someMethodDefinedInInterface(string $argument) : Result { return $this-&gt;proxy-&gt;someMethodDefinedInInterface($argument); } } You would then: Map the factory for the original service to the implementation name. Create a factory that consumes the original service, and produces the proxy. Map the interface name to the factory that creates the proxy. // in config/autoload/dependencies.global.php: return [ 'dependencies' =&gt; [ 'factories' =&gt; [ OriginalImplementation::class =&gt; OriginalImplementationFactory::class, OriginalInterface::class =&gt; ProxyServiceFactory::class, ], ], ]; If you were writing to the interface, and not the implementation, you can now guarantee that any non-interface methods that changed state can now no longer be called. If the interface itself defines methods that modify state, we recommend writing a proxy that implements those methods as no-ops and/or that raises exceptions when those methods are invoked. (The latter approach ensures that you discover quickly when code is exercising those methods.) In each case, you would then use a delegator factory , to decorate the original instance in the proxy class: function (ContainerInterface $container, string $name, callable $callback) { return new ProxyService($callback()); } (You can also use the delegator factory approach with the previous proxy service example.) Extension When a service does not implement an interface, but exposes methods that change internal state, you can extend the original class to make the methods that change state into no-ops, or have them raise exceptions. (The latter approach ensures that you discover quickly when code is exercising those methods.) As an example, let's say you have a class DataMapper that defines a method setTable() in it, and that method would change the database table the mapper would query. This is a potentially bad situation! We could extend the class as follows: class StatelessDataMapper extends DataMapper { public function setTable(string $table) : void { throw new \\DomainException(sprintf( '%s should not be called in production code!', __METHOD__ )); } } In your factory that creates an instance of DataMapper , have it instead return a StatelessDataMapper instance, and you're now safe. Factories Another approach is to modify your consuming code to accept a factory that will produce the service you'll consume, instead of the service itself. This approach ensures that the service is created only when needed, mitigating any state change issues. As an example, consider the following middleware that currently consumes a template renderer: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this-&gt;renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { return new HtmlResponse($this-&gt;renderer-&gt;render( 'app::some-handler', [] )); } } What we will do is modify it to accept a callable to the constructor. We will then call that factory just before we need the renderer; we will not store the result in the handler, as we want to ensure we have a new instance each time. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var callable */ private $rendererFactory; public function __construct(callable $rendererFactory) { $this-&gt;rendererFactory = $rendererFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { /** @var TemplateRendererInterface $renderer */ $renderer = ($this-&gt;rendererFactory)(); return new HtmlResponse($renderer-&gt;render( 'app::some-handler', [] )); } } From here, we create a factory for our dependency injection container that will return the factory we use here. As an example, if we are using the laminas-view integration , we might do the following: use Psr\\Container\\ContainerInterface; use Mezzio\\Template\\TemplateRendererInterface; use Mezzio\\LaminasView\\LaminasViewRendererFactory; class LaminasViewRendererFactoryFactory { public function __invoke(ContainerInterface $container) : callable { $factory = new LaminasViewRendererFactory(); return function () use ($container, $factory) : TemplateRendererInterface { return $factory($container); }; } } If we mapped this to the \"service\" Mezzio\\Template\\TemplateRendererInterfaceFactory , our factory for the SomeHandler class would then look like: use Mezzio\\Template\\TemplateRendererInterfaceFactory; function (ContainerInterface $container) : SomeHandler { return new SomeHandler( $container-&gt;get(TemplateRendererInterfaceFactory::class) ); } This approach ensures we get a new instance with known state at precisely the moment we wish to execute the functionality. By ensuring we do not store the instance in any way, we also ensure it is garbage collected when the instance goes out of scope (i.e., when the method ends). Handling the template data problem If we want our services to be stateless, how do we handle problems such as the documented addDefaultParam() issue referenced earlier ? In this case, the original problem was \"how do we get common request data into templates?\" The solution originally provided was to alter the state of the template renderer. Another solution, however, is one we've also documented previously: use server attributes to pass data between middleware . In this particular case, the middleware documented in the original solution could be modified to provide data to a request attribute, instead of altering the state of the template renderer. It might then become: namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Mezzio\\Router\\RouteResult; use Mezzio\\Session\\Authentication\\UserInterface; use Mezzio\\Session\\Flash\\FlashMessagesInterface; class TemplateDefaultsMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $routeResult = $request-&gt;getAttribute(RouteResult::class); $flashMessages = $request-&gt;getAttribute(FlashMessagesInterface::class); $defaults = [ // Inject the current user, or null if there isn't one. // This is named security so it will not interfere with your user admin pages 'security' =&gt; $request-&gt;getAttribute(UserInterface::class), // Inject the currently matched route name. 'matchedRouteName' =&gt; $routeResult ? $routeResult-&gt;getMatchedRouteName() : null, // Inject all flash messages 'notifications' =&gt; $flashMessages ? $flashMessages-&gt;getFlashes() : [], ]; return $handler-&gt;handle($request-&gt;withAttribute(__CLASS__, $defaults)); } } Once that change is made, you would then change your handler to do the following: Pull that attribute, providing a default [] value. Merge the pulled value with any local values when rendering the template. For example: $defaultParams = $request-&gt;getAttribute(TemplateDefaultsMiddleware::class, []); return new HtmlResponse($renderer-&gt;render( 'some::template', array_merge($defaultParams, [ // handler-specific parameters here ]) )); This approach, while it requires more work on the part of handler authors, ensures that the renderer state does not vary between requests, making it safer for usage with Swoole and other long-running processes.","title":"Considerations when using Swoole"},{"location":"v3/considerations/#considerations-when-using-swoole","text":"Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application.","title":"Considerations when using Swoole"},{"location":"v3/considerations/#long-running-processes","text":"When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead.","title":"Long-running processes"},{"location":"v3/considerations/#sessions","text":"Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives.","title":"Sessions"},{"location":"v3/considerations/#stateless-services","text":"The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail.","title":"Stateless services"},{"location":"v3/events/","text":"Swoole HTTP Server Events The Swoole\\Http\\Server emits a number of events during its lifecycle. Each is listened to by calling the server's on() method with the event name and a callback for handling the event. In each case, Swoole only allows exactly one listener. In some cases, Swoole will raise an exception when you attempt to register more listeners; in others, it will silently replace the listener. To make the system more flexible, version 3 of this library now has the Mezzio\\Swoole\\SwooleRequestHandlerRunner class compose a PSR-14 EventDispatcherInterface instance that is then triggered for each Swoole HTTP Server event. Additionally, the arguments passed to the Swoole listener are now aggregated into typed event classes, allowing access to the arguments by your PHP listener classes. Event classes All event classes are in the Mezzio\\Swoole\\Event namespace. Start Event Describes the \"start\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; /** * Describes \"start\" event */ class ServerStartEvent { public function getServer(): SwooleHttpServer; } Manager Start Event Describes the \"managerstart\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class ManagerStartEvent { public function getServer(): SwooleHttpServer; } Manager Stop Event Describes the \"managerstop\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class ManagerStopEvent { public function getServer(): SwooleHttpServer; } Worker Start Event Describes the \"workerstart\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class WorkerStartEvent { public function getServer(): SwooleHttpServer; public function getWorkerId(): int; } Worker Stop Event Describes the \"workerstop\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class WorkerStopEvent { public function getServer(): SwooleHttpServer; public function getWorkerId(): int; } Worker Error Event Describes the \"workererror\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class WorkerErrorEvent { public function getServer(): SwooleHttpServer; public function getWorkerId(): int; public function getExitCode(): int; public function getSignal(): int; } Request Event Describes the \"request\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Psr\\EventDispatcher\\StoppableEventInterface; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; use Swoole\\Http\\Server as SwooleHttpServer; class RequestEvent implements StoppableEventInterface { public function isPropagationStopped(): bool; public function getRequest(): SwooleHttpRequest; public function getResponse(): SwooleHttpResponse; public function responseSent(): void; } Before Reload Event Describes the \"beforereload\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class BeforeReloadEvent { public function getServer(): SwooleHttpServer; } After Reload Event Describes the \"afterreload\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class AfterReloadEvent { public function getServer(): SwooleHttpServer; } Task Event Describes the \"task\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Psr\\EventDispatcher\\StoppableEventInterface; use Swoole\\Http\\Server as SwooleHttpServer; class TaskEvent implements StoppableEventInterface { public function isPropagationStopped(): bool; public function getServer(): SwooleHttpServer; public function getTaskId(): int; public function getWorkerId(): int; /** * Data passed to the task() method */ public function getData(): mixed; /** * \"Return value\" of the task; what to pass to finish() * * @param mixed $returnValue */ public function setReturnValue($returnValue): void; /** @return mixed */ public function getReturnValue(); /** * Call this to indicate processing is complete, and to stop processing * further listeners. */ public function taskProcessingComplete(): void; } Finish Event Describes the \"finish\" event emitted by the Swoole HTTP Server, called when processing a task has been completed. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class TaskFinishEvent { public function getServer(): SwooleHttpServer; public function getTaskId(): int; /** * Data passed to the finish() method */ public function getData(): mixed; } Shutdown Event Describes the \"shutdown\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class ServerShutdownEvent { public function getServer(): SwooleHttpServer; } Listeners We define the following listeners for the specified events. All events and listeners are in the Mezzio\\Swoole\\Event namespace. ServerStartEvent : ServerStartListener : initializes the master and manager PIDs, sets the working directory, sets the master process name, and logs that the server has started. WorkerStartEvent : WorkerStartListener : sets the working directory, sets the worker process name, and logs the worker has started. HotCodeReloaderWorkerStartListener : initiates a hot code reload within the worker. RequestEvent RequestHandlerRequestListener : marshals a PSR-7 request from the Swoole HTTP request, passes it to the application request handler to generate a PSR-7 response, marshals and sends the Swoole HTTP Response from the PSR-7 response, and logs the request. If an error occurs marshaling the PSR-7 request, it will generate a PSR-7 error response, emit it, and log the request. In both cases, it marks the responseSent() in the event, stopping propagation. StaticResourceRequestListener : attempts to process a static resource request; if it was able, it sends the Swoole HTTP Response, logs the access, and marks the responseSent() in the event, stopping propagation. Otherwise, it returns, allowing the next listener to handle the event. ServerShutdownEvent : ServerShutdownListener : destroys the master and manager PIDs, all worker processes, and logs the server shutdown. Short-circuiting Only one event among those provided can be short-circuited: Mezzio\\Swoole\\Event\\RequestEvent . All others will trigger every listener encountered. With regards to the Mezzio\\Swoole\\Event\\RequestEvent , the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener always stops propagation. As such, if you want other listeners on that event, they must resolve before that listener. An example of such a listener is the Mezzio\\Swoole\\Event\\StaticResourceRequestListener , which only stops propagation if it was able to resolve the request to a static resource. Providing a dispatcher and listeners The shipped ConfigProvider uses a factory for the Mezzio\\Swoole\\SwooleRequestHandlerRunner class that consumes the following services: Swoole\\Http\\Server , which represents the actual Swoole HTTP Server instance to run. Mezzio\\Swoole\\Event\\EventDispatcherInterface SwooleRequestHandlerRunner accepts any PSR-14 instance. The service referenced by its factory is a marker interface used only as a service name; this is done to allow you to use a different PSR-14 instance for the web server versus other services in your application. By default, the Mezzio\\Swoole\\Event\\EventDispatcherInterface service points to Mezzio\\Swoole\\Event\\EventDispatcher , which is a simple PSR-14 dispatcher implementation. That service in turn consumes Mezzio\\Swoole\\Event\\SwooleListenerProvider . The factory for SwooleListenerProvider , Mezzio\\Swoole\\Event\\SwooleListenerProviderFactory , consumes the config service, looking for the following configuration: [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ 'EventClassName' =&gt; [ // service names of listeners ], ], ], ], ] Listeners for each event type are attached in the order they are discovered. We recommend using the SwooleListenerProvider service to aggregate the various listeners for Swoole server events, even if you do not use the shipped EventDispatcher implementation. Most PSR-14 libraries have functionality for aggregating multiple providers, and should allow you to compose the SwooleListenerProvider within them. FAQ Removing the StaticResourceRequestListener","title":"Swoole HTTP Server Events"},{"location":"v3/events/#swoole-http-server-events","text":"The Swoole\\Http\\Server emits a number of events during its lifecycle. Each is listened to by calling the server's on() method with the event name and a callback for handling the event. In each case, Swoole only allows exactly one listener. In some cases, Swoole will raise an exception when you attempt to register more listeners; in others, it will silently replace the listener. To make the system more flexible, version 3 of this library now has the Mezzio\\Swoole\\SwooleRequestHandlerRunner class compose a PSR-14 EventDispatcherInterface instance that is then triggered for each Swoole HTTP Server event. Additionally, the arguments passed to the Swoole listener are now aggregated into typed event classes, allowing access to the arguments by your PHP listener classes.","title":"Swoole HTTP Server Events"},{"location":"v3/events/#event-classes","text":"All event classes are in the Mezzio\\Swoole\\Event namespace.","title":"Event classes"},{"location":"v3/events/#listeners","text":"We define the following listeners for the specified events. All events and listeners are in the Mezzio\\Swoole\\Event namespace. ServerStartEvent : ServerStartListener : initializes the master and manager PIDs, sets the working directory, sets the master process name, and logs that the server has started. WorkerStartEvent : WorkerStartListener : sets the working directory, sets the worker process name, and logs the worker has started. HotCodeReloaderWorkerStartListener : initiates a hot code reload within the worker. RequestEvent RequestHandlerRequestListener : marshals a PSR-7 request from the Swoole HTTP request, passes it to the application request handler to generate a PSR-7 response, marshals and sends the Swoole HTTP Response from the PSR-7 response, and logs the request. If an error occurs marshaling the PSR-7 request, it will generate a PSR-7 error response, emit it, and log the request. In both cases, it marks the responseSent() in the event, stopping propagation. StaticResourceRequestListener : attempts to process a static resource request; if it was able, it sends the Swoole HTTP Response, logs the access, and marks the responseSent() in the event, stopping propagation. Otherwise, it returns, allowing the next listener to handle the event. ServerShutdownEvent : ServerShutdownListener : destroys the master and manager PIDs, all worker processes, and logs the server shutdown.","title":"Listeners"},{"location":"v3/events/#providing-a-dispatcher-and-listeners","text":"The shipped ConfigProvider uses a factory for the Mezzio\\Swoole\\SwooleRequestHandlerRunner class that consumes the following services: Swoole\\Http\\Server , which represents the actual Swoole HTTP Server instance to run. Mezzio\\Swoole\\Event\\EventDispatcherInterface SwooleRequestHandlerRunner accepts any PSR-14 instance. The service referenced by its factory is a marker interface used only as a service name; this is done to allow you to use a different PSR-14 instance for the web server versus other services in your application. By default, the Mezzio\\Swoole\\Event\\EventDispatcherInterface service points to Mezzio\\Swoole\\Event\\EventDispatcher , which is a simple PSR-14 dispatcher implementation. That service in turn consumes Mezzio\\Swoole\\Event\\SwooleListenerProvider . The factory for SwooleListenerProvider , Mezzio\\Swoole\\Event\\SwooleListenerProviderFactory , consumes the config service, looking for the following configuration: [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ 'EventClassName' =&gt; [ // service names of listeners ], ], ], ], ] Listeners for each event type are attached in the order they are discovered. We recommend using the SwooleListenerProvider service to aggregate the various listeners for Swoole server events, even if you do not use the shipped EventDispatcher implementation. Most PSR-14 libraries have functionality for aggregating multiple providers, and should allow you to compose the SwooleListenerProvider within them.","title":"Providing a dispatcher and listeners"},{"location":"v3/events/#faq","text":"Removing the StaticResourceRequestListener","title":"FAQ"},{"location":"v3/hot-code-reload/","text":"Hot Code Reload To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production! Requirements ext-inotify This library ships with an inotify based implementation of Mezzio\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded. Configuration The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php use Mezzio\\Swoole\\Event\\HotCodeReloaderWorkerStartListener; use Mezzio\\Swoole\\Event\\WorkerStartEvent; return [ 'mezzio-swoole' =&gt; [ 'hot-code-reload' =&gt; [ // Time in milliseconds between checks to changes in files. 'interval' =&gt; 500, 'paths' =&gt; [ // List of paths, either files or directories, to scan for changes. // By default this is empty; you will need to configure it. // A common value: getcwd(), ], ], 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ // Register the hot code reloader listener with the WorkerStartEvent WorkerStartEvent::class =&gt; [ HotCodeReloaderWorkerStartListener::class, ], ], ], ], ]; Logging When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation. Limitations Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Hot Code Reloading"},{"location":"v3/hot-code-reload/#hot-code-reload","text":"To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production!","title":"Hot Code Reload"},{"location":"v3/hot-code-reload/#requirements","text":"ext-inotify This library ships with an inotify based implementation of Mezzio\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded.","title":"Requirements"},{"location":"v3/hot-code-reload/#configuration","text":"The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php use Mezzio\\Swoole\\Event\\HotCodeReloaderWorkerStartListener; use Mezzio\\Swoole\\Event\\WorkerStartEvent; return [ 'mezzio-swoole' =&gt; [ 'hot-code-reload' =&gt; [ // Time in milliseconds between checks to changes in files. 'interval' =&gt; 500, 'paths' =&gt; [ // List of paths, either files or directories, to scan for changes. // By default this is empty; you will need to configure it. // A common value: getcwd(), ], ], 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ // Register the hot code reloader listener with the WorkerStartEvent WorkerStartEvent::class =&gt; [ HotCodeReloaderWorkerStartListener::class, ], ], ], ], ];","title":"Configuration"},{"location":"v3/hot-code-reload/#logging","text":"When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation.","title":"Logging"},{"location":"v3/hot-code-reload/#limitations","text":"Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Limitations"},{"location":"v3/how-it-works/","text":"How it works When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation acts similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling. Performance The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"How it works"},{"location":"v3/how-it-works/#how-it-works","text":"When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation acts similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling.","title":"How it works"},{"location":"v3/how-it-works/#performance","text":"The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"Performance"},{"location":"v3/intro/","text":"Swoole Open Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel. Install swoole You can install the Open Swoole extension on Linux or Mac environments using the following commands: $ pecl install openswoole For more information on the extension, visit its package details on PECL . Legacy Swoole compatibility Since version 3.4.0, mezzio-swoole can work with either the original Swoole extension or the new community Open Swoole extension, as each defines the same classes, interfaces, and constants consumed by mezzio-swoole. Install mezzio-swoole To install this package, use Composer : $ composer require mezzio/mezzio-swoole Swoole with Mezzio mezzio-swoole enables an Mezzio application to be executed with the Open Swoole or original Swoole extensions. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/laminas mezzio:swoole:start This command will execute Swoole on localhost via port 8080 . Other commands To get a list of all available commands, run the command without arguments: $ ./vendor/bin/laminas and look for commands starting with mezzio:swoole: . If you add the argument help before any command name, the tooling will provide you with more detailed information on that command. Mezzio skeleton versions prior to 3.1.0 The above will work immediately after installing mezzio-swoole if you are using a version of mezzio-skeleton from 3.1.0 or later. For applications based on previous versions of the skeleton, you will need to create a configuration file such as config/autoload/mezzio-swoole.global.php or config/autoload/mezzio-swoole.local.php with the following contents: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return (new ConfigProvider())(); You can change the host address and/or host name as well as the port using a configuration file, as follows: // In config/autoload/swoole.local.php: return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, ], ], ]; Providing additional Swoole configuration You can also configure the Swoole HTTP server using an options key to specify any accepted Swoole settings. For instance, the following configuration demonstrates enabling SSL: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ // Available in Swoole 4.1 and up; enables coroutine support // for most I/O operations: 'enable_coroutine' =&gt; true, // Configure Swoole HTTP Server: 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, 'mode' =&gt; SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS; // SWOOLE_BASE is the default 'protocol' =&gt; SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server 'options' =&gt; [ // Set the SSL certificate and key paths for SSL support: 'ssl_cert_file' =&gt; 'path/to/ssl.crt', 'ssl_key_file' =&gt; 'path/to/ssl.key', // Whether or not the HTTP server should use coroutines; // enabled by default, and generally should not be disabled: 'enable_coroutine' =&gt; true, // Overwrite the default location of the pid file; // required when you want to run multiple instances of your service in different ports: 'pid_file' =&gt; 'path/to/pid_file.pid', ], // Since 2.1.0: Set the process name prefix. // The master process will be named `{prefix}-master`, // worker processes will be named `{prefix}-worker-{id}`, // and task worker processes will be named `{prefix}-task-worker-{id}` 'process-name' =&gt; 'your-app', ], ], ]; SSL support By default, Swoole is not compiled with SSL support. To enable SSL in Swoole, it must be configured with the --enable-openssl or --with-openssl-dir=/path/to/openssl option. Serving static files We support serving static files. By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Our static resource capabilities are fairly comprehensive; please see the chapter on static resources for full details on configuration.","title":"Introduction"},{"location":"v3/intro/#swoole","text":"Open Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel.","title":"Swoole"},{"location":"v3/intro/#install-swoole","text":"You can install the Open Swoole extension on Linux or Mac environments using the following commands: $ pecl install openswoole For more information on the extension, visit its package details on PECL .","title":"Install swoole"},{"location":"v3/intro/#install-mezzio-swoole","text":"To install this package, use Composer : $ composer require mezzio/mezzio-swoole","title":"Install mezzio-swoole"},{"location":"v3/intro/#swoole-with-mezzio","text":"mezzio-swoole enables an Mezzio application to be executed with the Open Swoole or original Swoole extensions. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/laminas mezzio:swoole:start This command will execute Swoole on localhost via port 8080 .","title":"Swoole with Mezzio"},{"location":"v3/logging/","text":"Logging Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400). Access Logs Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically. Formatting logs The Apache web server has long provided flexible and robust logging capabilities, and its formats are used across a variety of web servers and logging platforms. As such, we have chosen to use its formats for our standard implementation. However, we allow you to plug in your own system as needed. You can refer to the Apache mod_log_config documentation in order to understand the available placeholders available for format strings. Formatting is provided to the Psr3AccessLogDecorator via instances of the interface Mezzio\\Swoole\\Log\\AccessLogFormatterInterface : interface AccessLogFormatterInterface { public function format(AccessLogDataMap $map) : string; } AccessLogDataMap is a class used internally by the Psr3AccessLogDecorator in order to map Apache log placeholders to request/response values. Our default AccessLogFormatterInterface implementation, AccessLogFormatter , provides constants referencing the most common formats, but also allows you to use arbitrary log formats that use the standard Apache placeholders. The formats we include by default are: AccessLogFormatter::FORMAT_COMMON : Apache common log format: %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost: %v %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMBINED : Apache combined log format: %h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-Agent}i\" AccessLogFormatter::FORMAT_REFERER : %{Referer}i -&gt; %U AccessLogFormatter::FORMAT_AGENT : %{User-Agent}i AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %&gt;s %b'; AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format: %h %l %u %t “%r” %&gt;s %O ; AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format: %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i” ; AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost: %v:%p %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i\" ; Configuring a logger You may subsitute your own logger implementation into the Swoole request handler runner. Manual usage If you are manually instantiating a Mezzio\\Swoole\\SwooleRequestHandlerRunner instance, you may provide it as the seventh argument to the constructor: use Mezzio\\Swoole\\SwooleRequestHandlerRunner; $runner = new SwooleRequestHandlerRunner( $application, $serverRequestFactory, $serverRequestErrorResponseGenerator, $pidManager, $serverFactory, $staticResourceHandler, $logger // &lt;-- AccessLoggerInterface instance ); Container usage If you are using a PSR-11 container, the SwooleRequestHandlerRunnerFactory will retrieve a log instance using the Mezzio\\Swoole\\Log\\AccessLogInterface service. You have two options for substituting your own logger from there. First, if you already have a service which resolves to a Psr\\Log\\LoggerInterface instance, you can configure it by providing its name: 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'logger' =&gt; [ 'logger-name' =&gt; 'my_logger', // define the logger service name here ], ], ], If you don't want to manually provide the service name but you are okay with re-using your existing PSR-3 logger, the provided Mezzio\\Swoole\\Log\\AccessLogFactory will use the Psr\\Log\\LoggerInterface service to create a Psr3AccessLogDecorator instance. The Mezzio\\Swoole\\Log\\AccessLogFactory will resolve the logger instance by using the Mezzio\\Swoole\\Log\\SwooleLogger service. This factory also allows you to specify a custom AccessLogFormatterInterface instance if you want. It will look up a service by the fully-qualified interface name, and use it if present. Otherwise, it creates an AccessLogFormatter instance for you. In both cases the factory will also look at the following configuration values: 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'logger' =&gt; [ 'format' =&gt; string, // one of the AccessLogFormatter::FORMAT_* // constants, or a custom format string 'use-hostname-lookups' =&gt; bool, // Set to true to enable hostname lookups ], ], ], Using Monolog as a PSR-3 logger When using Monolog with a StreamHandler , you must supply a file or a stream resource descriptor. We recommend using one of the following: php://stdout is a good choice, as this will generally write to the current console. php://stderr is also a good choice, as this will generally write to the current console, and allows you to filter based on that output stream. When using Docker , generally one of either /proc/1/fd/1 or /proc/1/fd/2 can be used, and are analogous to STDOUT and STDERR , respectively. We recommend using php://stdout and php://stderr instead, as these will be mapped to the correct locations by the language. ErrorLogHandler If you plan to write to STDERR , you might consider instead using the Monolog ErrorLogHandler , as this will use PHP's error_log() mechanism to write to the configured PHP error log. You can then either introspect that location, or configure the error_log php.ini setting to point to either /dev/stderr or, if on Docker, /proc/1/fd/2 . Additionally, we recommend using the PsrLogMessageProcessor with any Monolog handler to ensure that any templated parameters are expanded by the logger. As an example, the following is a factory that wires a StreamHandler to a Monolog\\Logger instance. use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use Monolog\\Processor\\PsrLogMessageProcessor; class LoggerFactory { public function __invoke(ContainerInterface $container) : LoggerInterface { $logger = new Logger('swoole-http-server'); $logger-&gt;pushHandler(new StreamHandler( 'php://stdout', Logger::INFO, $bubble = true, $expandNewLines = true )); $logger-&gt;pushProcessor(new PsrLogMessageProcessor()); return $logger; } } If you then wire this to the Psr\\Log\\LoggerInterface service, it will be used by Swoole for the purposes of access logs as well.","title":"Logging"},{"location":"v3/logging/#logging","text":"Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400).","title":"Logging"},{"location":"v3/logging/#access-logs","text":"Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically.","title":"Access Logs"},{"location":"v3/logging/#configuring-a-logger","text":"You may subsitute your own logger implementation into the Swoole request handler runner.","title":"Configuring a logger"},{"location":"v3/migration/","text":"Migration This document covers changes between version 2 and version 3, and how you may update your code to adapt to them. SwooleRequestHandlerRunner The internals of Mezzio\\Swoole\\SwooleRequestHandlerRunner have changed entirely. As a result, the constructor signature has also changed. Before, it read: public function __construct( Psr\\Http\\Server\\RequestHandlerInterface $handler, callable $serverRequestFactory, callable $serverRequestErrorResponseGenerator, Mezzio\\Swoole\\PidManager $pidManager, Swoole\\Http\\Server $httpServer, Mezzio\\Swoole\\StaticResourceHandlerInterface $staticResourceHandler = null, Mezzio\\Swoole\\Log\\AccessLogInterface $logger = null, string $processName = self::DEFAULT_PROCESS_NAME, ?Mezzio\\Swoole\\HotCodeReload\\Reloader $hotCodeReloader = null ) It now reads: public function __construct( Swoole\\Http\\Server $httpServer, Psr\\EventDispatcher\\EventDispatcherInterface $dispatcher ) As such, if you were providing your own factory for the class, or instantiating it manually, you will need to update your code. See the chapter on events for more information on how the the PSR-14 event dispatcher is used internally, and what listeners are provided. Reloader The class Mezzio\\Swoole\\HotCodeReload\\Reloader and its associated factory have been removed. Use the HotCodeReloaderWorkerStartListener instead. Additionally, with version 3, you will need to specify which paths you want to scan for changes via configuration. Please see the hot code reloading section on Configuration for details. Tasks In version 2 of this package, if you wanted to use the Swoole HTTP Server task functionality, you needed to: Set the task_worker_num option for the server instance in configuration. Create and register a task event handler with the server instance. With version 3 of this package, we now always register a task event handler (see the Swoole HTTP Server Events and Triggering Async Tasks chapters for details), which means you only need to configure the task_worker_num setting. Alternately, you can pass the --num-task-workers|-t option with a numeric number of task workers to either of the mezzio:swoole:start or mezzio:swoole:reload console commands (see Command line usage section below for details). Command line usage In releases prior to version 3, the package shipped with its own binary, mezzio-swoole , and defined the commands start , stop , status , and reload . Starting with version 3, the package now leverages laminas-cli , exposing the commands mezzio:swoole:start , mezzio:swoole:stop , mezzio:swoole:status , and mezzio:swoole:reload . As such, if you started the server as follows: $ ./vendor/bin/mezzio-swoole start you will now start it using: $ ./vendor/bin/laminas mezzio:swoole:start Usage of other commands will change similarly.","title":"Migration"},{"location":"v3/migration/#migration","text":"This document covers changes between version 2 and version 3, and how you may update your code to adapt to them.","title":"Migration"},{"location":"v3/migration/#swoolerequesthandlerrunner","text":"The internals of Mezzio\\Swoole\\SwooleRequestHandlerRunner have changed entirely. As a result, the constructor signature has also changed. Before, it read: public function __construct( Psr\\Http\\Server\\RequestHandlerInterface $handler, callable $serverRequestFactory, callable $serverRequestErrorResponseGenerator, Mezzio\\Swoole\\PidManager $pidManager, Swoole\\Http\\Server $httpServer, Mezzio\\Swoole\\StaticResourceHandlerInterface $staticResourceHandler = null, Mezzio\\Swoole\\Log\\AccessLogInterface $logger = null, string $processName = self::DEFAULT_PROCESS_NAME, ?Mezzio\\Swoole\\HotCodeReload\\Reloader $hotCodeReloader = null ) It now reads: public function __construct( Swoole\\Http\\Server $httpServer, Psr\\EventDispatcher\\EventDispatcherInterface $dispatcher ) As such, if you were providing your own factory for the class, or instantiating it manually, you will need to update your code. See the chapter on events for more information on how the the PSR-14 event dispatcher is used internally, and what listeners are provided.","title":"SwooleRequestHandlerRunner"},{"location":"v3/migration/#reloader","text":"The class Mezzio\\Swoole\\HotCodeReload\\Reloader and its associated factory have been removed. Use the HotCodeReloaderWorkerStartListener instead. Additionally, with version 3, you will need to specify which paths you want to scan for changes via configuration. Please see the hot code reloading section on Configuration for details.","title":"Reloader"},{"location":"v3/migration/#tasks","text":"In version 2 of this package, if you wanted to use the Swoole HTTP Server task functionality, you needed to: Set the task_worker_num option for the server instance in configuration. Create and register a task event handler with the server instance. With version 3 of this package, we now always register a task event handler (see the Swoole HTTP Server Events and Triggering Async Tasks chapters for details), which means you only need to configure the task_worker_num setting. Alternately, you can pass the --num-task-workers|-t option with a numeric number of task workers to either of the mezzio:swoole:start or mezzio:swoole:reload console commands (see Command line usage section below for details).","title":"Tasks"},{"location":"v3/migration/#command-line-usage","text":"In releases prior to version 3, the package shipped with its own binary, mezzio-swoole , and defined the commands start , stop , status , and reload . Starting with version 3, the package now leverages laminas-cli , exposing the commands mezzio:swoole:start , mezzio:swoole:stop , mezzio:swoole:status , and mezzio:swoole:reload . As such, if you started the server as follows: $ ./vendor/bin/mezzio-swoole start you will now start it using: $ ./vendor/bin/laminas mezzio:swoole:start Usage of other commands will change similarly.","title":"Command line usage"},{"location":"v3/static-resources/","text":"Static Resources One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Disabling static resources By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ]; Middleware The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers). Providing your own middleware If you want to disable middleware, or to provide an alternate list of middleware (including your own!), you will need to provide an alternate StaticResourceHandler factory. In most cases, you can extend StaticResourceHandlerFactory and override the configureMiddleware(array $config) : array method to do so. Be sure to remember to add a dependencies setting mapping the StaticResourceHandlerInterface service to your new factory when done! Configuration We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' =&gt; true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ]; Security warning Never add php as an allowed static file extension, as doing so could expose the source code of your PHP application! Document root If no document_root configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root does not exist, we raise an exception. Default extension/content-types By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Configuration Example The example which follows provides the following options: Sets the document root to /var/www/htdocs . Adds a custom extension / content-type map. Provides a clearstatcache interval of 2 hours. Selects the \"strong\" ETag algorithm. Indicates a gzip compression level of 3. Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files. Sets Cache-Control directives for plain text files. // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'enable' =&gt; true, 'document-root' =&gt; '/var/www/htdocs', 'type-map' =&gt; [ 'css' =&gt; 'text/css', 'gif' =&gt; 'image/gif', 'ico' =&gt; 'image/x-icon', 'jpg' =&gt; 'image/jpg', 'jpeg' =&gt; 'image/jpg', 'js' =&gt; 'application/javascript', 'png' =&gt; 'image/png', 'svg' =&gt; 'image/svg+xml', 'txt' =&gt; 'text/plain', ], 'clearstatcache-interval' =&gt; 7200, 'etag-type' =&gt; 'strong', 'gzip' =&gt; [ 'level' =&gt; 3, ], 'directives' =&gt; [ '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-transform', ], 'last-modified' =&gt; true, 'etag' =&gt; true, ], '/\\.txt$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-cache', ], ], ], ], ], ], ]; Writing Middleware Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() . Providing an alternative mechanism for sending response content In some cases, you may want to alter how the Swoole\\Http\\Response receives the body content. By default, we use Swoole\\Http\\Response::sendfile() . However, this may not work well when performing tasks such as compression, appending a watermark, etc. As an example, the GzipMiddleware adds a compression filter to a filehandle representing the file to send, and then calls Swoole\\Http\\Response::write() in a loop until all content is sent. To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback() method as detailed in the section above within your middleware. Alternative static resource handlers As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration. Example alternate static resource handler: StaticMappedResourceHandler Since 2.7.0 The default static resource handler, Mezzio\\Swoole\\StaticResourceHandler , requires all files to be in the specified document root directory (by default, \"public\") when instantiating the handler. If you are using modules generating templates with associated file assets (JavaScript, CSS, etc.), those files must be copied to the \"public\" directory if you wish to allow access to them. This can be done via scripting, but is one more step to consider when testing or deploying a site. Ideally, a module should be able to contain both its template and any dependencies that template relies upon. For example, assume you have a module, AwesomeModule, with a handler called \"HomeHandler\", which renders the 'home' template. You designate the prefix, /awesome-home for rendering the assets. The structure of your module files looks like this: AwesomeModule ├── src | ├── Handler | | ├── HomeHandler.php | | ├── HomeHandlerFactory.php | ├── ConfigProvider.php ├── templates │ ├── home | | ├── home.html | | ├── style.css │ ├── layouts In your home.html template, you can refer to the style.css file, using /awesome-home as follows: &lt;link href=\"/awesome-home/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; Currently, however, this will cause errors, as the stylesheet will not be available under the public/ tree of the application. You would need to copy or symlink the files to the appropriate location to make that work. The StaticMappedResourceHandler solves this problem. Using StaticMappedResourceHandler To use Mezzio\\Swoole\\StaticMappedResourceHandler from an application or module: Define what your URI prefix will be (e.g., /awesome-home ). Update references to linkable resources in your templates to use the desired prefix (e.g., &lt;script src='/awesome-home/style.css'&gt;&lt;/script&gt; ). In your application/module configuration (or ConfigProvider ), add the relationship between your prefix ( awesome-home ) and any directories containing the assets. In the application's configuration, set the alias of Mezzio\\Swoole\\StaticResourceHandlerInterface to use Mezzio\\Swoole\\StaticMappedResourceHandler . For step #3, in your module's ConfigProvider, you can add a configuration setting as follows: public function __invoke() : array { return [ 'config' =&gt; [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'mapped-document-roots' =&gt; [ 'awesome-home' =&gt; __DIR__ . '/../../templates/home' ] ] ] ] ] ]; } Note that prefixes are always the first part after the host, and specifying the initial slash is optional (i.e. awsesome-home and /awesome-home both work and represent the same thing). In step #4, in your application's configuration ( autoload/dependencies.global.php is a good place), override the default implementation of StaticResourceHandlerInterface : return [ 'dependencies' =&gt; [ 'aliases' =&gt; [ Mezzio\\Swoole\\StaticResourceHandlerInterface::class =&gt; Mezzio\\Swoole\\StaticMappedResourceHandler::class // Fully\\Qualified\\ClassOrInterfaceName::class =&gt; Fully\\Qualified\\ClassName::class, ], // etc. For step #3, an alternative to storing a configuration is dynamically associating /awesome-home to a directory in code (probably within a factory). This approach could be useful if the directory of the assets isn't know until runtime. use Psr\\Container\\ContainerInterface; use Mezzio\\Template\\TemplateRendererInterface; use Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface; class AwesomeHomeHandlerFactory { public function __invoke(ContainerInterface $container) : DocumentationViewHandler { // Establish location for the home template assets $repo = $container-&gt;get(FileLocationRepositoryInterface::class); $repo-&gt;addMappedDocumentRoot( 'awesome-home', realpath(__DIR__ . '/../../templates/home') ); return new AwesomeHomeHandler( $container-&gt;get(TemplateRendererInterface::class) ); } } When the template renders, the client will request /awesome-home/style.css , which the StaticMappedResourceHandler will now retrieve from the templates/home/ folder of the module. Mezzio\\Swoole\\StaticMappedResourceHandler uses the Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepository (which implements Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface ) to maintain an association of URI prefixes with file directories. If you require using a file location that requires authentication, decompression, etc. you can override the default functionality by creating your own implementation of Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface .","title":"Static Resources"},{"location":"v3/static-resources/#static-resources","text":"One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Disabling static resources By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ];","title":"Static Resources"},{"location":"v3/static-resources/#middleware","text":"The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers).","title":"Middleware"},{"location":"v3/static-resources/#configuration","text":"We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' =&gt; true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ];","title":"Configuration"},{"location":"v3/static-resources/#writing-middleware","text":"Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() .","title":"Writing Middleware"},{"location":"v3/static-resources/#alternative-static-resource-handlers","text":"As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Alternative static resource handlers"},{"location":"v3/static-resources/#example-alternate-static-resource-handler-staticmappedresourcehandler","text":"Since 2.7.0 The default static resource handler, Mezzio\\Swoole\\StaticResourceHandler , requires all files to be in the specified document root directory (by default, \"public\") when instantiating the handler. If you are using modules generating templates with associated file assets (JavaScript, CSS, etc.), those files must be copied to the \"public\" directory if you wish to allow access to them. This can be done via scripting, but is one more step to consider when testing or deploying a site. Ideally, a module should be able to contain both its template and any dependencies that template relies upon. For example, assume you have a module, AwesomeModule, with a handler called \"HomeHandler\", which renders the 'home' template. You designate the prefix, /awesome-home for rendering the assets. The structure of your module files looks like this: AwesomeModule ├── src | ├── Handler | | ├── HomeHandler.php | | ├── HomeHandlerFactory.php | ├── ConfigProvider.php ├── templates │ ├── home | | ├── home.html | | ├── style.css │ ├── layouts In your home.html template, you can refer to the style.css file, using /awesome-home as follows: &lt;link href=\"/awesome-home/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; Currently, however, this will cause errors, as the stylesheet will not be available under the public/ tree of the application. You would need to copy or symlink the files to the appropriate location to make that work. The StaticMappedResourceHandler solves this problem.","title":"Example alternate static resource handler: StaticMappedResourceHandler"},{"location":"v3/table/","text":"Using Swoole Tables in Your Application Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor. Initialize the Table Within the Constructor You must call your table's create() method, and this must be done prior to initializing any worker processes; if you fail to do so, your table will not work. We recommend doing this in your table class's constructor. Creating a Table As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this-&gt;column('x', self::TYPE_FLOAT); $this-&gt;column('y', self::TYPE_FLOAT); $this-&gt;column('z', self::TYPE_FLOAT); $this-&gt;create(); } } Creating Your Table Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' =&gt; [ // ... Vector3dTable::class =&gt; new Vector3dTable(), ], ]; } Using the Table Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container-&gt;get(Vector3dTable::class) (to use our previous example). Troubleshooting If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table-&gt;create() in your custom table's constructor.","title":"Using Swoole Tables"},{"location":"v3/table/#using-swoole-tables-in-your-application","text":"Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor.","title":"Using Swoole Tables in Your Application"},{"location":"v3/table/#creating-a-table","text":"As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this-&gt;column('x', self::TYPE_FLOAT); $this-&gt;column('y', self::TYPE_FLOAT); $this-&gt;column('z', self::TYPE_FLOAT); $this-&gt;create(); } }","title":"Creating a Table"},{"location":"v3/table/#creating-your-table","text":"Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' =&gt; [ // ... Vector3dTable::class =&gt; new Vector3dTable(), ], ]; }","title":"Creating Your Table"},{"location":"v3/table/#using-the-table","text":"Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container-&gt;get(Vector3dTable::class) (to use our previous example).","title":"Using the Table"},{"location":"v3/table/#troubleshooting","text":"If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table-&gt;create() in your custom table's constructor.","title":"Troubleshooting"},{"location":"v3/cookbook/static-resource-listener-removal/","text":"Removing the StaticResourceRequestListener By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ];","title":"Removing the StaticResourceRequestListener"},{"location":"v3/cookbook/static-resource-listener-removal/#removing-the-staticresourcerequestlistener","text":"By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ];","title":"Removing the StaticResourceRequestListener"},{"location":"v3/cookbook/swoole-not-starting/","text":"Swoole-based server always returns home page The problem You have started your Swoole-based web-server using ./vendor/bin/laminas mezzio:swoole:start , but every request is returned with a status 200 response and the contents of the home page. The solution This is generally caused by having the mezzio-swoole configuration provider too early in your application configuration, which then causes the default Mezzio configuration to overwrite the mezzio-swoole application runner. As an example, if the definition of the ConfigAggregator in your config/config.php file looks something like this: $aggregator = new ConfigAggregator([ \\Mezzio\\Swoole\\ConfigProvider::class, \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the position of the Mezzio\\Swoole\\ConfigProvider::class entry at the top. This can happen if you have previously removed the original entry from the config/config.php as provided by the skeleton project, or if you hand-crafted your config/config.php file , and then later used composer require mezzio/mezzio-swoole`, as the component installer injects at the start of the aggregator definition. The mezzio-swoole package provides a custom implementation of an HTTP Handler Runner . Because it defines the same service name as the one provided by laminas/laminas-httphandlerrunner, the mezzio-swoole ConfigProvider must appear later during aggregation to ensure it takes precedence: $aggregator = new ConfigAggregator([ \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, \\Mezzio\\Swoole\\ConfigProvider::class, // &lt;-- Here or later! // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the change in position for the Mezzio\\Swoole\\ConfigProvider:class entry in the above example.","title":"Swoole-based server always returns home page"},{"location":"v3/cookbook/swoole-not-starting/#swoole-based-server-always-returns-home-page","text":"","title":"Swoole-based server always returns home page"},{"location":"v3/cookbook/swoole-not-starting/#the-problem","text":"You have started your Swoole-based web-server using ./vendor/bin/laminas mezzio:swoole:start , but every request is returned with a status 200 response and the contents of the home page.","title":"The problem"},{"location":"v3/cookbook/swoole-not-starting/#the-solution","text":"This is generally caused by having the mezzio-swoole configuration provider too early in your application configuration, which then causes the default Mezzio configuration to overwrite the mezzio-swoole application runner. As an example, if the definition of the ConfigAggregator in your config/config.php file looks something like this: $aggregator = new ConfigAggregator([ \\Mezzio\\Swoole\\ConfigProvider::class, \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the position of the Mezzio\\Swoole\\ConfigProvider::class entry at the top. This can happen if you have previously removed the original entry from the config/config.php as provided by the skeleton project, or if you hand-crafted your config/config.php file , and then later used composer require mezzio/mezzio-swoole`, as the component installer injects at the start of the aggregator definition. The mezzio-swoole package provides a custom implementation of an HTTP Handler Runner . Because it defines the same service name as the one provided by laminas/laminas-httphandlerrunner, the mezzio-swoole ConfigProvider must appear later during aggregation to ensure it takes precedence: $aggregator = new ConfigAggregator([ \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, \\Mezzio\\Swoole\\ConfigProvider::class, // &lt;-- Here or later! // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the change in position for the Mezzio\\Swoole\\ConfigProvider:class entry in the above example.","title":"The solution"},{"location":"v4/async-tasks/","text":"Triggering Async Tasks Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes — allowing your application to continue responding to requests while the server processes your task. Configuring the Server Process for Tasks In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they trigger, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute in the order they are queued. 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; true, //optional to enable coroutines and useful for tasks coroutines 'swoole-http-server' =&gt; [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 8080, 'options' =&gt; [ 'worker_num' =&gt; 4, // The number of HTTP Server Workers 'task_worker_num' =&gt; 4, // The number of Task Workers 'task_enable_coroutine' =&gt; true, // optional to turn on task coroutine support ], ], ]; CLI options for worker_num and task_worker_num Each of the worker_num and task_worker_num options have corresponding options in the mezzio:swoole:start and mezzio:swoole:reload console commands: --num-workers|-w can be used to specify the number of HTTP Server Workers --num-task-workers|-t can be used to specify the number of Task Workers Task Events Mezzio\\Swoole\\SwooleRequestHandlerRunner registers listeners on the Swoole\\Http\\Server \"task\" and \"finish\" events. \"task\" is triggered when $server-&gt;task() is called, and \"finish\" is triggered when a task worker calls $trigger-&gt;finish() . Each of the listeners that the SwooleRequestHandlerRunner class registers in turn dispatch an event via its composed PSR-14 event dispatcher : Mezzio\\Swoole\\Event\\TaskEvent is dispatched via the \"task\" listener. Mezzio\\Swoole\\Event\\TaskFinishEvent is dispatched via the \"finish\" listener. Registering Task Listeners Registering listeners is the same as for other events: you will specify one or more of the above event types, pointing to a list of listeners that are defined as services in your container: // in config/autoload/mezzio.global.php: use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\TaskEvent::class =&gt; [ Your\\TaskLoggerListener::class, Your\\TaskEventListener::class, ], ], ], ], ]; TaskFinishEvent listener not required The \"finish\" event primarily exists to allow you to know when a given task has completed processing. In most cases, you can have a single listener that logs completion of the given task ID, ignoring the return value. Shipped task listeners This package ships two listeners that you can use to process tasks: Mezzio\\Swoole\\Task\\TaskEventDispatchListener and Mezzio\\Task\\TaskInvokerListener . TaskEventDispatchListener Mezzio\\Swoole\\Task\\TaskEventDispatchListener composes a PSR-14 event dispatcher and a PSR-3 logger instance. When invoked, it retrieves the data from the TaskEvent (via TaskEvent::getData() ). If that data is not an object, it does nothing. Otherwise, it treats it as an event, passing it to the composed event dispatcher, and setting the TaskEvent 's return value to the event returned by the dispatcher. Once complete, it marks task processing as complete on the event. To register this listener, use the following configuration: // in config/autoload/mezzio.global.php: use Mezzio\\Swoole\\Event; use Mezzio\\Swoole\\Task\\TaskEventDispatchListener; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\TaskEvent::class =&gt; [ TaskEventDispatchListener::class, ], ], ], ], ]; TaskInvokerListener Mezzio\\Swoole\\Task\\TaskInvokerListener works with a suite of other classes to allow processing task data. It composes a PSR-11 container and a PSR-3 logger instance. When invoked, it pulls the data from the TaskEvent (via TaskEvent::getData() ); if the data does not implement Mezzio\\Swoole\\Task\\TaskInterface , it does nothing and returns immediately. Otherwise, it invokes the task instance, passing it the PSR-11 container as the sole argument. When done, it marks task processing complete in the TaskEvent . The TaskInterface has the following definition: namespace Mezzio\\Swoole\\Task; use JsonSerializable; use Psr\\Container\\ContainerInterface; interface TaskInterface extends JsonSerializable { /** * @return mixed */ public function __invoke(ContainerInterface $container); } The idea is that you can initialize a task as follows: $server-&gt;task(new Task( function ($data) { // process the data }, $data )); And then the TaskInvokerListener will intercept it, identify a task instance, and invoke it in order to process it. To make this work, the package ships two TaskInterface implementations. The first is Mezzio\\Swoole\\Task\\Task , which composes the code that will process the task data, and the task data itself (as the \"payload\"): namespace Mezzio\\Swoole\\Task; use Psr\\Container\\ContainerInterface; final class Task implements TaskInterface { /** @var callable */ private $handler; private array $payload; public function __construct(callable $handler, ...$payload) { $this-&gt;handler = $handler; $this-&gt;payload = $payload; } /** * Container argument ignored in this implementation. */ public function __invoke(ContainerInterface $container) { return ($this-&gt;handler)(...$this-&gt;payload); } // serialization details intentionally left out of listing } This works exactly like the prior example: instantiate the Task with the handler and any data it should process. However, this task implementation has one caveat: the $handler MUST be serializable, and NOT contain references to other objects or resources (such as a database connection). The reason is because the Task instance is serialized and sent to another process completely, where it is then deserialized. To solve this limitation, the second implementation, Mezzio\\Swoole\\Task\\ServiceBasedTask , composes a service name and the task data to process. During invocation, it pulls the service from the supplied container instance, and then uses the service to process the task: namespace Mezzio\\Swoole\\Task; use Psr\\Container\\ContainerInterface; final class ServiceBasedTask implements TaskInterface { private array $payload; private string $serviceName; public function __construct(string $serviceName, ...$payload) { $this-&gt;serviceName = $serviceName; $this-&gt;payload = $payload; } public function __invoke(ContainerInterface $container) : void { $deferred = $container-&gt;get($this-&gt;serviceName); $listener = $deferred instanceof DeferredServiceListener ? $deferred-&gt;getListener() : $deferred; $listener(...$this-&gt;payload); } // serialization details intentionally left out of listing } What is the DeferredServiceListener ? It's a decorator for an invokable handler, generally a PSR-14 event listener. The idea behind the class is to allow dispatching events normally via a PSR-14 event dispatcher in your code, but having the listener queue a task that it then processes itself. To better understand the idea, let's look at the DeferredServiceListener : namespace Mezzio\\Swoole\\Task; use Swoole\\Http\\Server as SwooleHttpServer; final class DeferredServiceListener { private SwooleHttpServer $server; /** @var callable */ private $listener; private string $serviceName; public function __construct(SwooleHttpServer $server, callable $listener, string $serviceName) { $this-&gt;server = $server; $this-&gt;listener = $listener; $this-&gt;serviceName = $serviceName; } public function __invoke(object $event) : void { $this-&gt;server-&gt;task(new ServiceBasedTask($this-&gt;serviceName, $event)); } public function getListener(): callable { return $this-&gt;listener; } } In your configuration, you will use the Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator to decorate your event listener using the above class: // In config/autoload/dependencies.global.php: use Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator; return [ 'dependences' =&gt; [ 'factories' =&gt; [ App\\Listener\\UserCreationListener::class =&gt; App\\Listener\\UserCreationListenerFactory::class, ], 'delegators' =&gt; [ App\\Listener\\UserCreationListener::class =&gt; [ DeferredServiceListenerDelegator::class, ], ], ], ]; You would attach your listener as needed for your listener provider implementation, pulling the listener from the container: use App\\Event\\UserCreationEvent; use App\\Listener\\UserCreationListener; // Example where $listenerProvider is a Psr\\EventDispatcher\\ListenerProviderInterface // implementation, and defines a `listen()` method, and $container is a PSR-11 // container implementation: $listenerProvider = $factory(); $listenerProvider-&gt;listen(UserCreationEvent::class, $container-&gt;get(UserCreationListener::class)); Somewhere in your code, you might then dispatch the UserCreationEvent : use App\\Event\\UserCreationEvent; $dispatcher-&gt;dispatch(new UserCreationEvent($someData)); At this point, since the listener is decorated in a DeferredServiceListener instance, it queues a ServiceBasedTask . When the task worker goes to invoke the ServiceBasedTask , it pulls the service from the container... which ends up decorating it as a DeferredServiceListener again. To prevent infinite recursion, where the listener keeps queueing tasks for itself, the ServiceBasedTask checks to see if we have a DeferredServiceListener , and, if so, retrieves the actual listener it decorates from it. While this approach may seem convoluted, what it enables is the use of other services from your DI container when processing the task, including databases, caching, logging, and more. On top of that, it allows you to remove any references in your code to the Swoole HTTP server instance, isolating your code from the details of how the code actually executes behind a PSR-14 event dispatcher. This is the recommended way to queue and process tasks with mezzio-swoole. Examples Manually Triggering Tasks in Handlers Manually triggering tasks is not recommended, as it couples your application to Swoole, preventing usage in non-async paradigms as well as alternate async contexts. It can also make testing your application more difficult. We recommend the approach described in the section \"Dispatching a ServiceBasedTask via a PSR-14 Event Dispatcher\" . If you want to manually dispatch a task, you will need to: Compose the Swoole\\Http\\Server instance in your class. Call that instance's task() method with the data representing the task. As an example, we will create a request handler that composes the HTTP server instance. namespace Example; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Swoole\\Http\\Server as HttpServer; class TaskTriggeringHandler implements RequestHandlerInterface { /** @var ResponseFactoryInterface */ private $responseFactory; /** @var HttpServer */ private $server; public function __construct( HttpServer $server, ResponseFactoryInterface $responseFactory ) { $this-&gt;server = $server; $this-&gt;responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // Gather data from request $data = $request-&gt;getParsedBody(); // task() returns a task identifier, if you want to use it; otherwise, // you can ignore the return value. $taskIdentifier = $this-&gt;server-&gt;task([ 'to' =&gt; $data['email'], 'subject' =&gt; $data['subject'], 'message' =&gt; $data['message'], ]); // The task() method is asynchronous, so execution continues immediately. return $this-&gt;responseFactory()-&gt;createResponse(); } } Your handler will require a factory: namespace Example; use Psr\\Container\\ContainerInterface; use Psr\\Http\\Message\\ResponseFactoryInterface; use Swoole\\Http\\Server as HttpServer; class TaskTriggeringHandlerFactory { public function __invoke(ContainerInterface $container): TaskTriggeringHandler { return new TaskTriggeringHandler( $container-&gt;get(HttpServer::class), $container-&gt;get(ResponseFactoryInterface::class) ); } } And you will then need to notify the container configuration: // in config/autoload/global.php or similar: use Example\\TaskTriggeringHandler; use Example\\TaskTriggeringHandlerFactory; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ TaskTriggeringHandler::class =&gt; TaskTriggeringHandlerFactory::class, ], ], ]; Logging TaskEvent listener The following listener will listen to a TaskEvent , and log the information using the syslog. namespace Example; use Mezzio\\Swoole\\Event\\TaskEvent; use function date; use function sprintf; use function syslog; use function var_dump; use const LOG_INFO; class LoggingListener { public function __invoke(TaskEvent $event): void { syslog(LOG_INFO, sprintf( '[%s] [%d] %s', date('c'), $event-&gt;getTaskId(), var_dump($event-&gt;getData()) )); } } You would configure the application to use the listener as follows: // in config/autoload/swoole.global.php or similar: use Example\\LoggingListener; use Mezzio\\Swoole\\Event\\TaskEvent; return [ 'dependencies' =&gt; [ 'invokables' =&gt; [ LoggingListener::class =&gt; LoggingListener::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskEvent::class =&gt; [ LoggingListener::class, ], ], ], ], ]; To trigger the event, you will create a task using a Swoole\\Http\\Server instance: $server-&gt;task($data); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Logging TaskFinishEvent listener The following listener will listen to a TaskFinishEvent , and log the return value using the syslog. It looks almost identical to the previous example. namespace Example; use Mezzio\\Swoole\\Event\\TaskFinishEvent; use function date; use function sprintf; use function syslog; use function var_dump; use const LOG_INFO; class TaskCompletionLoggingListener { public function __invoke(TaskFinishEvent $event): void { syslog(LOG_INFO, sprintf( '[%s] [%d] %s', date('c'), $event-&gt;getTaskId(), var_dump($event-&gt;getReturnValue()) )); } } Similar to the previous example, you would configure the application to use the listener as follows: // in config/autoload/swoole.global.php or similar: use Example\\TaskCompletionLoggingListener; use Mezzio\\Swoole\\Event\\TaskFinishEvent; return [ 'dependencies' =&gt; [ 'invokables' =&gt; [ TaskCompletionLoggingListener::class =&gt; TaskCompletionLoggingListener::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskFinishEvent::class =&gt; [ TaskCompletionLoggingListener::class, ], ], ], ], ]; Unlike the previous example, however, you do not need to trigger this event yourself; it gets triggered by the SwooleRequestHandlerRunner . Queueing task data for the TaskEventDispatchListener In this example, we will configure the TaskEventDispatchListener as a TaskEvent listener. The TaskEventDispatchListener will in turn have a listener attached for a custom event, SomeDeferrableTask . We will queue a SomeDeferrableTask instance via the Swoole HTTP server task() method to defer its execution to the custom listener we create. First, we will create the custom task type: namespace Example; class SomeDeferrableTask { } Next, we will create a listener for this event type: namespace Example; class SomeDeferrableTaskListener { public function __invoke(SomeDeferrableTask $event): void { // process the task here } } Next, we will configure listeners for the TaskEvent and our custom SomeDeferrableTask : // in config/autoload/swoole.global.php or similar: use Example\\SomeDeferrableTask; use Example\\SomeDeferrableTaskListener; use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Event\\TaskEventDispatchListener; return [ 'dependencies' =&gt; [ 'invokables' =&gt; [ SomeDeferrableTaskListener::class =&gt; SomeDeferrableTaskListener::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ SomeDeferrableTask::class =&gt; [ SomeDeferrableTaskListener::class, ], TaskEvent::class =&gt; [ TaskEventDispatchListener::class, ], ], ], ], ]; To trigger the event, you will create a task using a Swoole\\Http\\Server instance: $server-&gt;task(new SomeDeferrableTask()); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Queueing a Task for the TaskInvokerListener In this example, we register the TaskInvokerListener with the TaskEvent . We then create a Mezzio\\Swoole\\Task\\Task instance and use the Swoole HTTP server to queue the task. First, we will configure the TaskInvokerListener for the TaskEvent : // in config/autoload/swoole.global.php or similar: use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Task\\TaskInvokerListener; return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskEvent::class =&gt; [ TaskInvokerListener::class, ], ], ], ], ]; Next, we will create a Task instance. The constructor for Mezzio\\Swoole\\Task\\Task expects a callable listener as the first argument, and then zero or more additional arguments representing the arguments to pass to the listener. use Mezzio\\Swoole\\Task\\Task; $task = new Task( static function(object $event): void { // Process the $event object }, (object) [ 'message' =&gt; 'hello world', ] ); Finally, we will enqueue the task using a Swoole\\Http\\Server instance: $server-&gt;task($task); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Queueing a ServiceBasedTask for the TaskInvokerListener In this example, we'll create a listener class that can handle a specific event type. We will create a factory for the listener, and register it in the DI container. We will also register the TaskInvokerListener with the TaskEvent . Finally, we will then create a Mezzio\\Swoole\\Task\\ServiceBasedTask instance using the service name for our listener and an instance of the event type it expects, and use the Swoole HTTP server to queue the task. First, let's define an event type: namespace Example; class SomeDeferrableEvent { /** @var string */ private $message; public function __construct(string $message) { $this-&gt;message = $message; } public function __toString(): string { return $this-&gt;message; } } Next, we will create a listener for this event type: namespace Example; use Psr\\Log\\LoggerInterface; class SomeDeferrableEventListener { /** @var LoggerInterface */ private $logger; public function __construct(LoggerInterface $logger) { $this-&gt;logger = $logger; } public function __invoke(SomeDeferrableEvent $event): void { $this-&gt;logger-&gt;info(sprintf('Message: %s', (string) $event)); } } The listener will require a factory: namespace Example; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; class SomeDeferrableEventListenerFactory { public function __invoke(ContainerInterface $container): SomeDeferrableEventListener { return new SomeDeferrableEventListener( $container-&gt;get(LoggerInterface::class) ); } } At this point, we turn to configuration. We will add dependency configuration for our listener (omitting the configuration for the logger service; we will assume you have done so already, or can figure out how to do so). We will also add configuration to bind the TaskInvokerListener to the TaskEvent . // in config/autoload/swoole.global.php or similar: use Example\\SomeDeferrableEventListener; use Example\\SomeDeferrableEventListenerFactory; use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Task\\TaskInvokerListener; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ SomeDeferrableEventListener::class =&gt; SomeDeferrableEventListenerFactory::class, ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ TaskEvent::class =&gt; [ TaskInvokerListener::class, ], ], ], ], ]; Next, we will create a ServiceBasedTask instance. The constructor for Mezzio\\Swoole\\Task\\Task expects the name of a service that can be pulled from the application DI container as the first argument, and then zero or more additional arguments representing the arguments to pass to the listener. The service is expected to be invokable (i.e., it MUST define the method __invoke() ). use Example\\SomeDeferrableEvent; use Example\\SomeDeferrableEventListener; use Mezzio\\Swoole\\Task\\ServiceBasedTask; $task = new ServiceBasedTask( SomeDeferrableEventListener::class, new SomeDeferrableEvent('hello world') ); Finally, we will enqueue the task using a Swoole\\Http\\Server instance: $server-&gt;task($task); See the \"Manually Triggering Tasks in Handlers\" example for details on injecting the Swoole HTTP server in a request handler. Dispatching a ServiceBasedTask via a PSR-14 Event Dispatcher This final example builds on the previous. We will use the same event and listener. However, instead of queueing the task via the Swoole HTTP server, we will queue it via a PSR-14 event dispatcher. To make that possible, we will add a delegator factory for our listener that will do the work of queueing the task for us. This example will make the assumption that you are using the same PSR-14 event dispatcher with both the SwooleRequestHandlerRunner and the rest of your application, and will re-purpose the Mezzio\\Swoole\\Event\\SwooleListenerProvider to also handle listeners for our Example\\SomeDeferrableEvent . First, we will define a handler that triggers this event: namespace Example; use Psr\\EventDispatcher\\EventDispatcherInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class MessageHandler implements RequestHandlerInterface { /** @var EventDispatcherInterface */ private $dispatcher; /** @var ResponseFactoryInterface */ private $responseFactory; public function __construct( EventDispatcherInterface $dispatcher, ResponseFactoryInterface $responseFactory ) { $this-&gt;dispatcher = $dispatcher; $this-&gt;responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request): ResponseInterface { $this-&gt;dispatcher-&gt;dispatch(new SomeDeferrableEvent('hello world')); return $this-&gt;responseFactory-&gt;createResponse(); } } This handler will need a factory. namespace Example; use Psr\\Container\\ContaienrInterface; use Psr\\EventDispatcher\\EventDispatcherInterface; use Psr\\Http\\Message\\ResponseFactoryInterface; class MessageHandlerFactory { public function __invoke(ContainerInterface $container): MessageHandler { return new MessageHandler( $container-&gt;get(EventDispatcherInterface::class), $container-&gt;get(ResponseFactoryInterface::class) ); } } The next step is changing configuration. We need to configure our container to tell it about our handler, as well as to add the Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator as a delegator factory for our Example\\SomeDeferrableEventListener . We will also add configuration to map our listener to our custom event. // in config/autoload/swoole.global.php or similar: use Example\\MessageHandler; use Example\\MessageHandlerFactory; use Example\\SomeDeferrableEvent; use Example\\SomeDeferrableEventListener; use Example\\SomeDeferrableEventListenerFactory; use Mezzio\\Swoole\\Event\\TaskEvent; use Mezzio\\Swoole\\Task\\TaskInvokerListener; use Mezzio\\Swoole\\Task\\DeferredServiceListenerDelegator; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ MessageHandler::class =&gt; MessageHandlerFactory::class, SomeDeferrableEventListener::class =&gt; SomeDeferrableEventListenerFactory::class, ], 'delegators' =&gt; [ SomeDeferrableEventListener::class =&gt; [ DeferredServiceListenerDelegator::class, ], ], ], 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ SomeDeferrableEvent::class =&gt; [ SomeDeferrableEventListener::class, ], TaskEvent::class =&gt; [ TaskInvokerListener::class, ], ], ], ], ]; At this point, we are done. When the handler dispatches the event, our listener is notified. However, the listener is decoreated via the DeferredServiceListenerDelegator , which will itself enqueue a ServiceBasedTask in the Swoole HTTP server, using the listener's service name and the event passed to the listener. The TaskInvokerListener then passes the container to the task, which pulls our listener and executes it with the event.","title":"Async Tasks"},{"location":"v4/async-tasks/#triggering-async-tasks","text":"Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes — allowing your application to continue responding to requests while the server processes your task.","title":"Triggering Async Tasks"},{"location":"v4/async-tasks/#configuring-the-server-process-for-tasks","text":"In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they trigger, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute in the order they are queued. 'mezzio-swoole' =&gt; [ 'enable_coroutine' =&gt; true, //optional to enable coroutines and useful for tasks coroutines 'swoole-http-server' =&gt; [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 8080, 'options' =&gt; [ 'worker_num' =&gt; 4, // The number of HTTP Server Workers 'task_worker_num' =&gt; 4, // The number of Task Workers 'task_enable_coroutine' =&gt; true, // optional to turn on task coroutine support ], ], ];","title":"Configuring the Server Process for Tasks"},{"location":"v4/async-tasks/#task-events","text":"Mezzio\\Swoole\\SwooleRequestHandlerRunner registers listeners on the Swoole\\Http\\Server \"task\" and \"finish\" events. \"task\" is triggered when $server-&gt;task() is called, and \"finish\" is triggered when a task worker calls $trigger-&gt;finish() . Each of the listeners that the SwooleRequestHandlerRunner class registers in turn dispatch an event via its composed PSR-14 event dispatcher : Mezzio\\Swoole\\Event\\TaskEvent is dispatched via the \"task\" listener. Mezzio\\Swoole\\Event\\TaskFinishEvent is dispatched via the \"finish\" listener.","title":"Task Events"},{"location":"v4/async-tasks/#registering-task-listeners","text":"Registering listeners is the same as for other events: you will specify one or more of the above event types, pointing to a list of listeners that are defined as services in your container: // in config/autoload/mezzio.global.php: use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\TaskEvent::class =&gt; [ Your\\TaskLoggerListener::class, Your\\TaskEventListener::class, ], ], ], ], ];","title":"Registering Task Listeners"},{"location":"v4/async-tasks/#shipped-task-listeners","text":"This package ships two listeners that you can use to process tasks: Mezzio\\Swoole\\Task\\TaskEventDispatchListener and Mezzio\\Task\\TaskInvokerListener .","title":"Shipped task listeners"},{"location":"v4/async-tasks/#examples","text":"","title":"Examples"},{"location":"v4/command-line/","text":"Command Line Tooling This package provides integration with laminas-cli , and provides the following commands: mezzio:swoole:start to start the server mezzio:swoole:stop to stop the server (when run in daemonized mode) mezzio:swoole:reload to reload the server (when run in daemonized mode) mezzio:swoole:status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/laminas help mezzio:swoole:start The mezzio:swoole:stop , mezzio:swoole:status , and mezzio:swoole:reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The mezzio:swoole:start command, however, may need customizations if you have customized your application bootstrap. The mezzio:swoole:start command The mezzio:swoole:start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), the number of task workers to spawn (provided via the --num-task-workers or -t option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Mezzio\\Application and Mezzio\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Mezzio skeleton application. Writing a custom mezzio:swoole:start command If your application needs alternate bootstrapping (e.g., if you have modified the public/index.php , or if you are using this package with a different middleware runtime), we recommend writing a custom mezzio:swoole:start command. As an example, let's say you have altered your application such that you're defining your routes in multiple files, and instead of: (require 'config/routes.php')($app, $factory, $container); you instead have something like: $handle = opendir('config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } You could write a command such as the following: // In src/App/Command/StartCommand.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; use Swoole\\Http\\Server as SwooleHttpServer; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; use Mezzio\\Application; use Mezzio\\MiddlewareFactory; use Mezzio\\Swoole\\Command\\StartCommand as BaseStartCommand; use Mezzio\\Swoole\\PidManager; class StartCommand extends BaseStartCommand { protected function execute(InputInterface $input, OutputInterface $output) : int { // This functionality is identical to the base start command, and should // be copy and pasted to your implementation: $this-&gt;pidManager = $this-&gt;container-&gt;get(PidManager::class); if ($this-&gt;isRunning()) { $output-&gt;writeln('&lt;error&gt;Server is already running!&lt;/error&gt;'); return 1; } $server = $this-&gt;container-&gt;get(SwooleHttpServer::class); $server-&gt;set([ 'daemonize' =&gt; $input-&gt;getOption('daemonize'), 'worker_num' =&gt; $input-&gt;getOption('num-workers') ?? self::DEFAULT_NUM_WORKERS, ]); /** @var \\Mezzio\\Application $app */ $app = $this-&gt;container-&gt;get(Application::class); /** @var \\Mezzio\\MiddlewareFactory $factory */ $factory = $this-&gt;container-&gt;get(MiddlewareFactory::class); // Execute programmatic/declarative middleware pipeline and routing // configuration statements (require 'config/pipeline.php')($app, $factory, $this-&gt;container); // // This is the new code from above: // $handle = opendir(getcwd() . '/config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } // And now we return to the original code: // Run the application $app-&gt;run(); return 0; } } You will also need to write a factory for the class: // In src/App/Command/StartCommandFactory.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; class StartCommandFactory { public function __invoke(ContainerInterface $container) : StartCommand { return new StartCommand($container); } } If this is all you're changing, you can map this new command to the existing Mezzio\\Swoole\\Command\\StartCommand service within your configuration: // in config/autoload/dependencies.global.php: use App\\Command\\StartCommandFactory; use Mezzio\\Swoole\\Command\\StartCommand; return [ 'dependencies' =&gt; [ 'factories' =&gt; [ StartCommand::class =&gt; StartCommandFactory::class, ], ], ]; Since the laminas binary uses your application configuration and container, this will substitute your command for the shipped command!","title":"Command Line Tooling"},{"location":"v4/command-line/#command-line-tooling","text":"This package provides integration with laminas-cli , and provides the following commands: mezzio:swoole:start to start the server mezzio:swoole:stop to stop the server (when run in daemonized mode) mezzio:swoole:reload to reload the server (when run in daemonized mode) mezzio:swoole:status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/laminas help mezzio:swoole:start The mezzio:swoole:stop , mezzio:swoole:status , and mezzio:swoole:reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The mezzio:swoole:start command, however, may need customizations if you have customized your application bootstrap.","title":"Command Line Tooling"},{"location":"v4/command-line/#the-mezzioswoolestart-command","text":"The mezzio:swoole:start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), the number of task workers to spawn (provided via the --num-task-workers or -t option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Mezzio\\Application and Mezzio\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Mezzio skeleton application.","title":"The mezzio:swoole:start command"},{"location":"v4/considerations/","text":"Considerations when using Swoole Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application. Long-running processes When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead. PDO Coroutine Support Please be aware that enabling coroutine support with Swoole\\Runtime::enableCoroutine() only decorates MySql PDO connections with coroutines; other drivers (e.g., pdo_pgsql) remain blocking as of Swoole 4.1.2. For more details, visit the related bug report on the Swoole issue tracker . Sessions Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives. mezzio-session-cache mezzio-session-cache provides a persistence adapter for mezzio-session that uses a PSR-6 CacheItemPoolInterface implementation for storing and retrieving sessions. This approach requires that you setup a backend cache storage for your session data. psr7-sessions/storageless PSR7Session provides session middleware that uses JWT tokens within the session cookie to transmit session data between the server and client. This approach requires no central session storage, but does impose limits on the amount of information you can store in a session. Stateless services The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail. Decoration If a service implements an interface, you can decorate the service to make it stateless. Well-written interfaces will be stateless by design, and not provide methods meant to internally change state. In these situations, you can create a proxy class that decorates the original service: class ProxyService implements OriginalInterface { /** @var OriginalInterface */ private $proxy; public function __construct(OriginalInterface $proxy) { $this-&gt;proxy = $proxy; } public function someMethodDefinedInInterface(string $argument) : Result { return $this-&gt;proxy-&gt;someMethodDefinedInInterface($argument); } } You would then: Map the factory for the original service to the implementation name. Create a factory that consumes the original service, and produces the proxy. Map the interface name to the factory that creates the proxy. // in config/autoload/dependencies.global.php: return [ 'dependencies' =&gt; [ 'factories' =&gt; [ OriginalImplementation::class =&gt; OriginalImplementationFactory::class, OriginalInterface::class =&gt; ProxyServiceFactory::class, ], ], ]; If you were writing to the interface, and not the implementation, you can now guarantee that any non-interface methods that changed state can now no longer be called. If the interface itself defines methods that modify state, we recommend writing a proxy that implements those methods as no-ops and/or that raises exceptions when those methods are invoked. (The latter approach ensures that you discover quickly when code is exercising those methods.) In each case, you would then use a delegator factory , to decorate the original instance in the proxy class: function (ContainerInterface $container, string $name, callable $callback) { return new ProxyService($callback()); } (You can also use the delegator factory approach with the previous proxy service example.) Extension When a service does not implement an interface, but exposes methods that change internal state, you can extend the original class to make the methods that change state into no-ops, or have them raise exceptions. (The latter approach ensures that you discover quickly when code is exercising those methods.) As an example, let's say you have a class DataMapper that defines a method setTable() in it, and that method would change the database table the mapper would query. This is a potentially bad situation! We could extend the class as follows: class StatelessDataMapper extends DataMapper { public function setTable(string $table) : void { throw new \\DomainException(sprintf( '%s should not be called in production code!', __METHOD__ )); } } In your factory that creates an instance of DataMapper , have it instead return a StatelessDataMapper instance, and you're now safe. Factories Another approach is to modify your consuming code to accept a factory that will produce the service you'll consume, instead of the service itself. This approach ensures that the service is created only when needed, mitigating any state change issues. As an example, consider the following middleware that currently consumes a template renderer: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this-&gt;renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { return new HtmlResponse($this-&gt;renderer-&gt;render( 'app::some-handler', [] )); } } What we will do is modify it to accept a callable to the constructor. We will then call that factory just before we need the renderer; we will not store the result in the handler, as we want to ensure we have a new instance each time. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Laminas\\Diactoros\\Response\\HtmlResponse; use Mezzio\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var callable */ private $rendererFactory; public function __construct(callable $rendererFactory) { $this-&gt;rendererFactory = $rendererFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { /** @var TemplateRendererInterface $renderer */ $renderer = ($this-&gt;rendererFactory)(); return new HtmlResponse($renderer-&gt;render( 'app::some-handler', [] )); } } From here, we create a factory for our dependency injection container that will return the factory we use here. As an example, if we are using the laminas-view integration , we might do the following: use Psr\\Container\\ContainerInterface; use Mezzio\\Template\\TemplateRendererInterface; use Mezzio\\LaminasView\\LaminasViewRendererFactory; class LaminasViewRendererFactoryFactory { public function __invoke(ContainerInterface $container) : callable { $factory = new LaminasViewRendererFactory(); return function () use ($container, $factory) : TemplateRendererInterface { return $factory($container); }; } } If we mapped this to the \"service\" Mezzio\\Template\\TemplateRendererInterfaceFactory , our factory for the SomeHandler class would then look like: use Mezzio\\Template\\TemplateRendererInterfaceFactory; function (ContainerInterface $container) : SomeHandler { return new SomeHandler( $container-&gt;get(TemplateRendererInterfaceFactory::class) ); } This approach ensures we get a new instance with known state at precisely the moment we wish to execute the functionality. By ensuring we do not store the instance in any way, we also ensure it is garbage collected when the instance goes out of scope (i.e., when the method ends). Handling the template data problem If we want our services to be stateless, how do we handle problems such as the documented addDefaultParam() issue referenced earlier ? In this case, the original problem was \"how do we get common request data into templates?\" The solution originally provided was to alter the state of the template renderer. Another solution, however, is one we've also documented previously: use server attributes to pass data between middleware . In this particular case, the middleware documented in the original solution could be modified to provide data to a request attribute, instead of altering the state of the template renderer. It might then become: namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Mezzio\\Router\\RouteResult; use Mezzio\\Session\\Authentication\\UserInterface; use Mezzio\\Session\\Flash\\FlashMessagesInterface; class TemplateDefaultsMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $routeResult = $request-&gt;getAttribute(RouteResult::class); $flashMessages = $request-&gt;getAttribute(FlashMessagesInterface::class); $defaults = [ // Inject the current user, or null if there isn't one. // This is named security so it will not interfere with your user admin pages 'security' =&gt; $request-&gt;getAttribute(UserInterface::class), // Inject the currently matched route name. 'matchedRouteName' =&gt; $routeResult ? $routeResult-&gt;getMatchedRouteName() : null, // Inject all flash messages 'notifications' =&gt; $flashMessages ? $flashMessages-&gt;getFlashes() : [], ]; return $handler-&gt;handle($request-&gt;withAttribute(__CLASS__, $defaults)); } } Once that change is made, you would then change your handler to do the following: Pull that attribute, providing a default [] value. Merge the pulled value with any local values when rendering the template. For example: $defaultParams = $request-&gt;getAttribute(TemplateDefaultsMiddleware::class, []); return new HtmlResponse($renderer-&gt;render( 'some::template', array_merge($defaultParams, [ // handler-specific parameters here ]) )); This approach, while it requires more work on the part of handler authors, ensures that the renderer state does not vary between requests, making it safer for usage with Swoole and other long-running processes.","title":"Considerations when using Swoole"},{"location":"v4/considerations/#considerations-when-using-swoole","text":"Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application.","title":"Considerations when using Swoole"},{"location":"v4/considerations/#long-running-processes","text":"When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead.","title":"Long-running processes"},{"location":"v4/considerations/#sessions","text":"Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives.","title":"Sessions"},{"location":"v4/considerations/#stateless-services","text":"The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: mezzio-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests — when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail.","title":"Stateless services"},{"location":"v4/events/","text":"Swoole HTTP Server Events The Swoole\\Http\\Server emits a number of events during its lifecycle. Each is listened to by calling the server's on() method with the event name and a callback for handling the event. In each case, Swoole only allows exactly one listener. In some cases, Swoole will raise an exception when you attempt to register more listeners; in others, it will silently replace the listener. To make the system more flexible, version 3 of this library now has the Mezzio\\Swoole\\SwooleRequestHandlerRunner service compose a PSR-14 EventDispatcherInterface instance that is then triggered for each Swoole HTTP Server event. Additionally, the arguments passed to the Swoole listener are now aggregated into typed event classes, allowing access to the arguments by your PHP listener classes. Event classes All event classes are in the Mezzio\\Swoole\\Event namespace. Start Event Describes the \"start\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; /** * Describes \"start\" event */ class ServerStartEvent { public function getServer(): SwooleHttpServer; } Manager Start Event Describes the \"managerstart\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class ManagerStartEvent { public function getServer(): SwooleHttpServer; } Manager Stop Event Describes the \"managerstop\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class ManagerStopEvent { public function getServer(): SwooleHttpServer; } Worker Start Event Describes the \"workerstart\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class WorkerStartEvent { public function getServer(): SwooleHttpServer; public function getWorkerId(): int; } Worker Stop Event Describes the \"workerstop\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class WorkerStopEvent { public function getServer(): SwooleHttpServer; public function getWorkerId(): int; } Worker Error Event Describes the \"workererror\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class WorkerErrorEvent { public function getServer(): SwooleHttpServer; public function getWorkerId(): int; public function getExitCode(): int; public function getSignal(): int; } Request Event Describes the \"request\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Psr\\EventDispatcher\\StoppableEventInterface; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; use Swoole\\Http\\Server as SwooleHttpServer; class RequestEvent implements StoppableEventInterface { public function isPropagationStopped(): bool; public function getRequest(): SwooleHttpRequest; public function getResponse(): SwooleHttpResponse; public function responseSent(): void; } Before Reload Event Describes the \"beforereload\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class BeforeReloadEvent { public function getServer(): SwooleHttpServer; } After Reload Event Describes the \"afterreload\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class AfterReloadEvent { public function getServer(): SwooleHttpServer; } Task Event Describes the \"task\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Psr\\EventDispatcher\\StoppableEventInterface; use Swoole\\Http\\Server as SwooleHttpServer; class TaskEvent implements StoppableEventInterface { public function isPropagationStopped(): bool; public function getServer(): SwooleHttpServer; public function getTaskId(): int; public function getWorkerId(): int; /** * Data passed to the task() method */ public function getData(): mixed; /** * \"Return value\" of the task; what to pass to finish() * * @param mixed $returnValue */ public function setReturnValue($returnValue): void; /** @return mixed */ public function getReturnValue(); /** * Call this to indicate processing is complete, and to stop processing * further listeners. */ public function taskProcessingComplete(): void; } Finish Event Describes the \"finish\" event emitted by the Swoole HTTP Server, called when processing a task has been completed. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class TaskFinishEvent { public function getServer(): SwooleHttpServer; public function getTaskId(): int; /** * Data passed to the finish() method */ public function getData(): mixed; } Shutdown Event Describes the \"shutdown\" event emitted by the Swoole HTTP Server. namespace Mezzio\\Swoole\\Event; use Swoole\\Http\\Server as SwooleHttpServer; class ServerShutdownEvent { public function getServer(): SwooleHttpServer; } Listeners We define the following listeners for the specified events. All events and listeners are in the Mezzio\\Swoole\\Event namespace. ServerStartEvent : ServerStartListener : initializes the master and manager PIDs, sets the working directory, sets the master process name, and logs that the server has started. WorkerStartEvent : WorkerStartListener : sets the working directory, sets the worker process name, and logs the worker has started. HotCodeReloaderWorkerStartListener : initiates a hot code reload within the worker. RequestEvent RequestHandlerRequestListener : marshals a PSR-7 request from the Swoole HTTP request, passes it to the application request handler to generate a PSR-7 response, marshals and sends the Swoole HTTP Response from the PSR-7 response, and logs the request. If an error occurs marshaling the PSR-7 request, it will generate a PSR-7 error response, emit it, and log the request. In both cases, it marks the responseSent() in the event, stopping propagation. StaticResourceRequestListener : attempts to process a static resource request; if it was able, it sends the Swoole HTTP Response, logs the access, and marks the responseSent() in the event, stopping propagation. Otherwise, it returns, allowing the next listener to handle the event. ServerShutdownEvent : ServerShutdownListener : destroys the master and manager PIDs, all worker processes, and logs the server shutdown. Short-circuiting Only one event among those provided can be short-circuited: Mezzio\\Swoole\\Event\\RequestEvent . All others will trigger every listener encountered. With regards to the Mezzio\\Swoole\\Event\\RequestEvent , the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener always stops propagation. As such, if you want other listeners on that event, they must resolve before that listener. An example of such a listener is the Mezzio\\Swoole\\Event\\StaticResourceRequestListener , which only stops propagation if it was able to resolve the request to a static resource. Providing a dispatcher and listeners The shipped ConfigProvider uses a factory for the Mezzio\\Swoole\\SwooleRequestHandlerRunner service that consumes the following services: Swoole\\Http\\Server , which represents the actual Swoole HTTP Server instance to run. Mezzio\\Swoole\\Event\\EventDispatcherInterface SwooleRequestHandlerRunner accepts any PSR-14 instance. The Mezzio\\Swoole\\Event\\EventDispatcherInterface service referenced by its factory is a marker interface used only as a service name; this is done to allow you to use a different PSR-14 instance for the web server versus other services in your application. By default, the Mezzio\\Swoole\\Event\\EventDispatcherInterface service points to Mezzio\\Swoole\\Event\\EventDispatcher , which is a simple PSR-14 dispatcher implementation. That service in turn consumes Mezzio\\Swoole\\Event\\SwooleListenerProvider . The factory for SwooleListenerProvider , Mezzio\\Swoole\\Event\\SwooleListenerProviderFactory , consumes the config service, looking for the following configuration: [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ 'EventClassName' =&gt; [ // service names of listeners ], ], ], ], ] Listeners for each event type are attached in the order they are discovered. We recommend using the SwooleListenerProvider service to aggregate the various listeners for Swoole server events, even if you do not use the shipped EventDispatcher implementation. Most PSR-14 libraries have functionality for aggregating multiple providers, and should allow you to compose the SwooleListenerProvider within them. FAQ Removing the StaticResourceRequestListener","title":"Swoole HTTP Server Events"},{"location":"v4/events/#swoole-http-server-events","text":"The Swoole\\Http\\Server emits a number of events during its lifecycle. Each is listened to by calling the server's on() method with the event name and a callback for handling the event. In each case, Swoole only allows exactly one listener. In some cases, Swoole will raise an exception when you attempt to register more listeners; in others, it will silently replace the listener. To make the system more flexible, version 3 of this library now has the Mezzio\\Swoole\\SwooleRequestHandlerRunner service compose a PSR-14 EventDispatcherInterface instance that is then triggered for each Swoole HTTP Server event. Additionally, the arguments passed to the Swoole listener are now aggregated into typed event classes, allowing access to the arguments by your PHP listener classes.","title":"Swoole HTTP Server Events"},{"location":"v4/events/#event-classes","text":"All event classes are in the Mezzio\\Swoole\\Event namespace.","title":"Event classes"},{"location":"v4/events/#listeners","text":"We define the following listeners for the specified events. All events and listeners are in the Mezzio\\Swoole\\Event namespace. ServerStartEvent : ServerStartListener : initializes the master and manager PIDs, sets the working directory, sets the master process name, and logs that the server has started. WorkerStartEvent : WorkerStartListener : sets the working directory, sets the worker process name, and logs the worker has started. HotCodeReloaderWorkerStartListener : initiates a hot code reload within the worker. RequestEvent RequestHandlerRequestListener : marshals a PSR-7 request from the Swoole HTTP request, passes it to the application request handler to generate a PSR-7 response, marshals and sends the Swoole HTTP Response from the PSR-7 response, and logs the request. If an error occurs marshaling the PSR-7 request, it will generate a PSR-7 error response, emit it, and log the request. In both cases, it marks the responseSent() in the event, stopping propagation. StaticResourceRequestListener : attempts to process a static resource request; if it was able, it sends the Swoole HTTP Response, logs the access, and marks the responseSent() in the event, stopping propagation. Otherwise, it returns, allowing the next listener to handle the event. ServerShutdownEvent : ServerShutdownListener : destroys the master and manager PIDs, all worker processes, and logs the server shutdown.","title":"Listeners"},{"location":"v4/events/#providing-a-dispatcher-and-listeners","text":"The shipped ConfigProvider uses a factory for the Mezzio\\Swoole\\SwooleRequestHandlerRunner service that consumes the following services: Swoole\\Http\\Server , which represents the actual Swoole HTTP Server instance to run. Mezzio\\Swoole\\Event\\EventDispatcherInterface SwooleRequestHandlerRunner accepts any PSR-14 instance. The Mezzio\\Swoole\\Event\\EventDispatcherInterface service referenced by its factory is a marker interface used only as a service name; this is done to allow you to use a different PSR-14 instance for the web server versus other services in your application. By default, the Mezzio\\Swoole\\Event\\EventDispatcherInterface service points to Mezzio\\Swoole\\Event\\EventDispatcher , which is a simple PSR-14 dispatcher implementation. That service in turn consumes Mezzio\\Swoole\\Event\\SwooleListenerProvider . The factory for SwooleListenerProvider , Mezzio\\Swoole\\Event\\SwooleListenerProviderFactory , consumes the config service, looking for the following configuration: [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ 'EventClassName' =&gt; [ // service names of listeners ], ], ], ], ] Listeners for each event type are attached in the order they are discovered. We recommend using the SwooleListenerProvider service to aggregate the various listeners for Swoole server events, even if you do not use the shipped EventDispatcher implementation. Most PSR-14 libraries have functionality for aggregating multiple providers, and should allow you to compose the SwooleListenerProvider within them.","title":"Providing a dispatcher and listeners"},{"location":"v4/events/#faq","text":"Removing the StaticResourceRequestListener","title":"FAQ"},{"location":"v4/hot-code-reload/","text":"Hot Code Reload To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production! Requirements ext-inotify This library ships with an inotify based implementation of Mezzio\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded. Configuration The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php use Mezzio\\Swoole\\Event\\HotCodeReloaderWorkerStartListener; use Mezzio\\Swoole\\Event\\WorkerStartEvent; return [ 'mezzio-swoole' =&gt; [ 'hot-code-reload' =&gt; [ // Time in milliseconds between checks to changes in files. 'interval' =&gt; 500, 'paths' =&gt; [ // List of paths, either files or directories, to scan for changes. // By default this is empty; you will need to configure it. // A common value: getcwd(), ], ], 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ // Register the hot code reloader listener with the WorkerStartEvent WorkerStartEvent::class =&gt; [ HotCodeReloaderWorkerStartListener::class, ], ], ], ], ]; Logging When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation. Limitations Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Hot Code Reloading"},{"location":"v4/hot-code-reload/#hot-code-reload","text":"To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production!","title":"Hot Code Reload"},{"location":"v4/hot-code-reload/#requirements","text":"ext-inotify This library ships with an inotify based implementation of Mezzio\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded.","title":"Requirements"},{"location":"v4/hot-code-reload/#configuration","text":"The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php use Mezzio\\Swoole\\Event\\HotCodeReloaderWorkerStartListener; use Mezzio\\Swoole\\Event\\WorkerStartEvent; return [ 'mezzio-swoole' =&gt; [ 'hot-code-reload' =&gt; [ // Time in milliseconds between checks to changes in files. 'interval' =&gt; 500, 'paths' =&gt; [ // List of paths, either files or directories, to scan for changes. // By default this is empty; you will need to configure it. // A common value: getcwd(), ], ], 'swoole-http-server' =&gt; [ 'listeners' =&gt; [ // Register the hot code reloader listener with the WorkerStartEvent WorkerStartEvent::class =&gt; [ HotCodeReloaderWorkerStartListener::class, ], ], ], ], ];","title":"Configuration"},{"location":"v4/hot-code-reload/#logging","text":"When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation.","title":"Logging"},{"location":"v4/hot-code-reload/#limitations","text":"Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Limitations"},{"location":"v4/how-it-works/","text":"How it works When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner service. The basic implementation acts similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling. Performance The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"How it works"},{"location":"v4/how-it-works/#how-it-works","text":"When you run an Mezzio application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in mezzio-swoole is a runner that enables the execution of an Mezzio application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Mezzio\\Swoole\\SwooleRequestHandlerRunner service. The basic implementation acts similar to the following: public function run() : void { $this-&gt;swooleHttpServer-&gt;on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server-&gt;host, $server-&gt;port); }); $this-&gt;swooleHttpServer-&gt;on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request-&gt;server['remote_addr'], $request-&gt;server['request_method'], $request-&gt;server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this-&gt;serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this-&gt;emitMarshalServerRequestException($emitter, $e); return; } $emitter-&gt;emit($this-&gt;handler-&gt;handle($psr7Request)); }); $this-&gt;swooleHttpServer-&gt;start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by laminas-diactoros ) via the class Mezzio\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Mezzio\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Mezzio application using mezzio-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling.","title":"How it works"},{"location":"v4/how-it-works/#performance","text":"The Laminas developers performed a benchmark running the default mezzio-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Mezzio with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option mezzio-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"Performance"},{"location":"v4/intro/","text":"Swoole Open Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel. Install swoole You can install the Open Swoole extension on Linux or Mac environments using the following commands: $ pecl install openswoole For more information on the extension, visit its package details on PECL . Legacy Swoole compatibility Since version 3.4.0, mezzio-swoole can work with either the original Swoole extension or the new community Open Swoole extension, as each defines the same classes, interfaces, and constants consumed by mezzio-swoole. Install mezzio-swoole To install this package, use Composer : $ composer require mezzio/mezzio-swoole Swoole with Mezzio mezzio-swoole enables an Mezzio application to be executed with the Open Swoole or original Swoole extensions. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/laminas mezzio:swoole:start This command will execute Swoole on localhost via port 8080 . Other commands To get a list of all available commands, run the command without arguments: $ ./vendor/bin/laminas and look for commands starting with mezzio:swoole: . If you add the argument help before any command name, the tooling will provide you with more detailed information on that command. Mezzio skeleton versions prior to 3.1.0 The above will work immediately after installing mezzio-swoole if you are using a version of mezzio-skeleton from 3.1.0 or later. For applications based on previous versions of the skeleton, you will need to create a configuration file such as config/autoload/mezzio-swoole.global.php or config/autoload/mezzio-swoole.local.php with the following contents: &lt;?php use Mezzio\\Swoole\\ConfigProvider; return (new ConfigProvider())(); You can change the host address and/or host name as well as the port using a configuration file, as follows: // In config/autoload/swoole.local.php: return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, ], ], ]; Providing additional Swoole configuration You can also configure the Swoole HTTP server using an options key to specify any accepted Swoole settings. For instance, the following configuration demonstrates enabling SSL: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ // Available in Swoole 4.1 and up; enables coroutine support // for most I/O operations: 'enable_coroutine' =&gt; true, // Configure Swoole HTTP Server: 'swoole-http-server' =&gt; [ 'host' =&gt; '192.168.0.1', 'port' =&gt; 9501, 'mode' =&gt; SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS; // SWOOLE_BASE is the default 'protocol' =&gt; SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server 'options' =&gt; [ // Set the SSL certificate and key paths for SSL support: 'ssl_cert_file' =&gt; 'path/to/ssl.crt', 'ssl_key_file' =&gt; 'path/to/ssl.key', // Whether or not the HTTP server should use coroutines; // enabled by default, and generally should not be disabled: 'enable_coroutine' =&gt; true, // Overwrite the default location of the pid file; // required when you want to run multiple instances of your service in different ports: 'pid_file' =&gt; 'path/to/pid_file.pid', ], // Since 2.1.0: Set the process name prefix. // The master process will be named `{prefix}-master`, // worker processes will be named `{prefix}-worker-{id}`, // and task worker processes will be named `{prefix}-task-worker-{id}` 'process-name' =&gt; 'your-app', ], ], ]; SSL support By default, Swoole is not compiled with SSL support. To enable SSL in Swoole, it must be configured with the --enable-openssl or --with-openssl-dir=/path/to/openssl option. Serving static files We support serving static files. By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Our static resource capabilities are fairly comprehensive; please see the chapter on static resources for full details on configuration.","title":"Introduction"},{"location":"v4/intro/#swoole","text":"Open Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel.","title":"Swoole"},{"location":"v4/intro/#install-swoole","text":"You can install the Open Swoole extension on Linux or Mac environments using the following commands: $ pecl install openswoole For more information on the extension, visit its package details on PECL .","title":"Install swoole"},{"location":"v4/intro/#install-mezzio-swoole","text":"To install this package, use Composer : $ composer require mezzio/mezzio-swoole","title":"Install mezzio-swoole"},{"location":"v4/intro/#swoole-with-mezzio","text":"mezzio-swoole enables an Mezzio application to be executed with the Open Swoole or original Swoole extensions. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/laminas mezzio:swoole:start This command will execute Swoole on localhost via port 8080 .","title":"Swoole with Mezzio"},{"location":"v4/logging/","text":"Logging Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400). Access Logs Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically. Formatting logs The Apache web server has long provided flexible and robust logging capabilities, and its formats are used across a variety of web servers and logging platforms. As such, we have chosen to use its formats for our standard implementation. However, we allow you to plug in your own system as needed. You can refer to the Apache mod_log_config documentation in order to understand the available placeholders available for format strings. Formatting is provided to the Psr3AccessLogDecorator via instances of the interface Mezzio\\Swoole\\Log\\AccessLogFormatterInterface : interface AccessLogFormatterInterface { public function format(AccessLogDataMap $map) : string; } AccessLogDataMap is a class used internally by the Psr3AccessLogDecorator in order to map Apache log placeholders to request/response values. Our default AccessLogFormatterInterface implementation, AccessLogFormatter , provides constants referencing the most common formats, but also allows you to use arbitrary log formats that use the standard Apache placeholders. The formats we include by default are: AccessLogFormatter::FORMAT_COMMON : Apache common log format: %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost: %v %h %l %u %t \"%r\" %&gt;s %b AccessLogFormatter::FORMAT_COMBINED : Apache combined log format: %h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-Agent}i\" AccessLogFormatter::FORMAT_REFERER : %{Referer}i -&gt; %U AccessLogFormatter::FORMAT_AGENT : %{User-Agent}i AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %&gt;s %b'; AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format: %h %l %u %t “%r” %&gt;s %O ; AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format: %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i” ; AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost: %v:%p %h %l %u %t “%r” %&gt;s %O “%{Referer}i” “%{User-Agent}i\" ; Configuring a logger You may subsitute your own logger implementation into the Swoole request handler runner. Manual usage If you are manually instantiating a Mezzio\\Swoole\\SwooleRequestHandlerRunner instance, you may provide it as the seventh argument to the constructor: use Mezzio\\Swoole\\SwooleRequestHandlerRunner; $runner = new SwooleRequestHandlerRunner( $application, $serverRequestFactory, $serverRequestErrorResponseGenerator, $pidManager, $serverFactory, $staticResourceHandler, $logger // &lt;-- AccessLoggerInterface instance ); Container usage If you are using a PSR-11 container, the SwooleRequestHandlerRunnerFactory will retrieve a log instance using the Mezzio\\Swoole\\Log\\AccessLogInterface service. You have two options for substituting your own logger from there. First, if you already have a service which resolves to a Psr\\Log\\LoggerInterface instance, you can configure it by providing its name: 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'logger' =&gt; [ 'logger-name' =&gt; 'my_logger', // define the logger service name here ], ], ], If you don't want to manually provide the service name but you are okay with re-using your existing PSR-3 logger, the provided Mezzio\\Swoole\\Log\\AccessLogFactory will use the Psr\\Log\\LoggerInterface service to create a Psr3AccessLogDecorator instance. The Mezzio\\Swoole\\Log\\AccessLogFactory will resolve the logger instance by using the Mezzio\\Swoole\\Log\\SwooleLogger service. This factory also allows you to specify a custom AccessLogFormatterInterface instance if you want. It will look up a service by the fully-qualified interface name, and use it if present. Otherwise, it creates an AccessLogFormatter instance for you. In both cases the factory will also look at the following configuration values: 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'logger' =&gt; [ 'format' =&gt; string, // one of the AccessLogFormatter::FORMAT_* // constants, or a custom format string 'use-hostname-lookups' =&gt; bool, // Set to true to enable hostname lookups ], ], ], Using Monolog as a PSR-3 logger When using Monolog with a StreamHandler , you must supply a file or a stream resource descriptor. We recommend using one of the following: php://stdout is a good choice, as this will generally write to the current console. php://stderr is also a good choice, as this will generally write to the current console, and allows you to filter based on that output stream. When using Docker , generally one of either /proc/1/fd/1 or /proc/1/fd/2 can be used, and are analogous to STDOUT and STDERR , respectively. We recommend using php://stdout and php://stderr instead, as these will be mapped to the correct locations by the language. ErrorLogHandler If you plan to write to STDERR , you might consider instead using the Monolog ErrorLogHandler , as this will use PHP's error_log() mechanism to write to the configured PHP error log. You can then either introspect that location, or configure the error_log php.ini setting to point to either /dev/stderr or, if on Docker, /proc/1/fd/2 . Additionally, we recommend using the PsrLogMessageProcessor with any Monolog handler to ensure that any templated parameters are expanded by the logger. As an example, the following is a factory that wires a StreamHandler to a Monolog\\Logger instance. use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use Monolog\\Processor\\PsrLogMessageProcessor; class LoggerFactory { public function __invoke(ContainerInterface $container) : LoggerInterface { $logger = new Logger('swoole-http-server'); $logger-&gt;pushHandler(new StreamHandler( 'php://stdout', Logger::INFO, $bubble = true, $expandNewLines = true )); $logger-&gt;pushProcessor(new PsrLogMessageProcessor()); return $logger; } } If you then wire this to the Psr\\Log\\LoggerInterface service, it will be used by Swoole for the purposes of access logs as well.","title":"Logging"},{"location":"v4/logging/#logging","text":"Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400).","title":"Logging"},{"location":"v4/logging/#access-logs","text":"Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Mezzio\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Mezzio\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically.","title":"Access Logs"},{"location":"v4/logging/#configuring-a-logger","text":"You may subsitute your own logger implementation into the Swoole request handler runner.","title":"Configuring a logger"},{"location":"v4/migration/","text":"Migration This document covers changes between version 3 and version 4, and how you may update your code to adapt to them. SwooleRequestHandlerRunner Version 3 pinned to the version 1 series of laminas/laminas-httphandlerrunner , which defined the class Laminas\\HttpHandlerRunner\\RequestHandlerRunner . mezzio-swoole extended that class via its own implementation Mezzio\\Swoole\\SwooleRequestHandlerRunner . Version 4 of mezzio-swoole pins to version 2 of laminas/laminas-httphandlerrunner. laminas-httphandlerrunner v2 introduces Laminas\\HttpHandlerRunner\\RequestHandlerInterface , and has its Laminas\\HttpHandlerRunner\\RequestHandlerRunner class implement this new interface; additionally, the class now marks itself final , which prevents extension, and thus requires a change in mezzio-swoole's implementation. Additionally, the base Mezzio package adopted laminas-httphandlerrunner v2.1 as its minimum supported version starting with its 3.8.0 release, and modified its Mezzio\\Application class constructor to typehint against Laminas\\HttpHandlerRunner\\RequestHandlerInterface instead of Laminas\\HttpHandlerRunner\\RequestHandlerRunner . The result is that mezzio-swoole v3 releases cannot be used with Mezzio versions 3.8 and newer. For version 4, Mezzio\\Swoole\\SwooleRequestHandlerRunner now implements Laminas\\HttpHandlerRunner\\RequestHandlerInterface , but does not extend Laminas\\HttpHandlerRunner\\RequestHandlerRunner (as it cannot). Further, the class is now marked final . As such, you can no longer extend Mezzio\\Swoole\\SwooleRequestHandlerRunner . To change behavior of the class, we recommend using its event system and attaching listeners to shape its behavior.","title":"Migration"},{"location":"v4/migration/#migration","text":"This document covers changes between version 3 and version 4, and how you may update your code to adapt to them.","title":"Migration"},{"location":"v4/migration/#swoolerequesthandlerrunner","text":"Version 3 pinned to the version 1 series of laminas/laminas-httphandlerrunner , which defined the class Laminas\\HttpHandlerRunner\\RequestHandlerRunner . mezzio-swoole extended that class via its own implementation Mezzio\\Swoole\\SwooleRequestHandlerRunner . Version 4 of mezzio-swoole pins to version 2 of laminas/laminas-httphandlerrunner. laminas-httphandlerrunner v2 introduces Laminas\\HttpHandlerRunner\\RequestHandlerInterface , and has its Laminas\\HttpHandlerRunner\\RequestHandlerRunner class implement this new interface; additionally, the class now marks itself final , which prevents extension, and thus requires a change in mezzio-swoole's implementation. Additionally, the base Mezzio package adopted laminas-httphandlerrunner v2.1 as its minimum supported version starting with its 3.8.0 release, and modified its Mezzio\\Application class constructor to typehint against Laminas\\HttpHandlerRunner\\RequestHandlerInterface instead of Laminas\\HttpHandlerRunner\\RequestHandlerRunner . The result is that mezzio-swoole v3 releases cannot be used with Mezzio versions 3.8 and newer. For version 4, Mezzio\\Swoole\\SwooleRequestHandlerRunner now implements Laminas\\HttpHandlerRunner\\RequestHandlerInterface , but does not extend Laminas\\HttpHandlerRunner\\RequestHandlerRunner (as it cannot). Further, the class is now marked final . As such, you can no longer extend Mezzio\\Swoole\\SwooleRequestHandlerRunner . To change behavior of the class, we recommend using its event system and attaching listeners to shape its behavior.","title":"SwooleRequestHandlerRunner"},{"location":"v4/static-resources/","text":"Static Resources One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Disabling static resources By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ]; Middleware The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers). Providing your own middleware If you want to disable middleware, or to provide an alternate list of middleware (including your own!), you will need to provide an alternate StaticResourceHandler factory. In most cases, you can extend StaticResourceHandlerFactory and override the configureMiddleware(array $config) : array method to do so. Be sure to remember to add a dependencies setting mapping the StaticResourceHandlerInterface service to your new factory when done! Configuration We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' =&gt; true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ]; Security warning Never add php as an allowed static file extension, as doing so could expose the source code of your PHP application! Document root If no document_root configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root does not exist, we raise an exception. Default extension/content-types By default, we serve files with extensions in the whitelist defined in the constant Mezzio\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Configuration Example The example which follows provides the following options: Sets the document root to /var/www/htdocs . Adds a custom extension / content-type map. Provides a clearstatcache interval of 2 hours. Selects the \"strong\" ETag algorithm. Indicates a gzip compression level of 3. Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files. Sets Cache-Control directives for plain text files. // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'enable' =&gt; true, 'document-root' =&gt; '/var/www/htdocs', 'type-map' =&gt; [ 'css' =&gt; 'text/css', 'gif' =&gt; 'image/gif', 'ico' =&gt; 'image/x-icon', 'jpg' =&gt; 'image/jpg', 'jpeg' =&gt; 'image/jpg', 'js' =&gt; 'application/javascript', 'png' =&gt; 'image/png', 'svg' =&gt; 'image/svg+xml', 'txt' =&gt; 'text/plain', ], 'clearstatcache-interval' =&gt; 7200, 'etag-type' =&gt; 'strong', 'gzip' =&gt; [ 'level' =&gt; 3, ], 'directives' =&gt; [ '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-transform', ], 'last-modified' =&gt; true, 'etag' =&gt; true, ], '/\\.txt$/' =&gt; [ 'cache-control' =&gt; [ 'public', 'no-cache', ], ], ], ], ], ], ]; Writing Middleware Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() . Providing an alternative mechanism for sending response content In some cases, you may want to alter how the Swoole\\Http\\Response receives the body content. By default, we use Swoole\\Http\\Response::sendfile() . However, this may not work well when performing tasks such as compression, appending a watermark, etc. As an example, the GzipMiddleware adds a compression filter to a filehandle representing the file to send, and then calls Swoole\\Http\\Response::write() in a loop until all content is sent. To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback() method as detailed in the section above within your middleware. Alternative static resource handlers As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration. Example alternate static resource handler: StaticMappedResourceHandler Since 2.7.0 The default static resource handler, Mezzio\\Swoole\\StaticResourceHandler , requires all files to be in the specified document root directory (by default, \"public\") when instantiating the handler. If you are using modules generating templates with associated file assets (JavaScript, CSS, etc.), those files must be copied to the \"public\" directory if you wish to allow access to them. This can be done via scripting, but is one more step to consider when testing or deploying a site. Ideally, a module should be able to contain both its template and any dependencies that template relies upon. For example, assume you have a module, AwesomeModule, with a handler called \"HomeHandler\", which renders the 'home' template. You designate the prefix, /awesome-home for rendering the assets. The structure of your module files looks like this: AwesomeModule ├── src | ├── Handler | | ├── HomeHandler.php | | ├── HomeHandlerFactory.php | ├── ConfigProvider.php ├── templates │ ├── home | | ├── home.html | | ├── style.css │ ├── layouts In your home.html template, you can refer to the style.css file, using /awesome-home as follows: &lt;link href=\"/awesome-home/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; Currently, however, this will cause errors, as the stylesheet will not be available under the public/ tree of the application. You would need to copy or symlink the files to the appropriate location to make that work. The StaticMappedResourceHandler solves this problem. Using StaticMappedResourceHandler To use Mezzio\\Swoole\\StaticMappedResourceHandler from an application or module: Define what your URI prefix will be (e.g., /awesome-home ). Update references to linkable resources in your templates to use the desired prefix (e.g., &lt;script src='/awesome-home/style.css'&gt;&lt;/script&gt; ). In your application/module configuration (or ConfigProvider ), add the relationship between your prefix ( awesome-home ) and any directories containing the assets. In the application's configuration, set the alias of Mezzio\\Swoole\\StaticResourceHandlerInterface to use Mezzio\\Swoole\\StaticMappedResourceHandler . For step #3, in your module's ConfigProvider, you can add a configuration setting as follows: public function __invoke() : array { return [ 'config' =&gt; [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ 'mapped-document-roots' =&gt; [ 'awesome-home' =&gt; __DIR__ . '/../../templates/home' ] ] ] ] ] ]; } Note that prefixes are always the first part after the host, and specifying the initial slash is optional (i.e. awsesome-home and /awesome-home both work and represent the same thing). In step #4, in your application's configuration ( autoload/dependencies.global.php is a good place), override the default implementation of StaticResourceHandlerInterface : return [ 'dependencies' =&gt; [ 'aliases' =&gt; [ Mezzio\\Swoole\\StaticResourceHandlerInterface::class =&gt; Mezzio\\Swoole\\StaticMappedResourceHandler::class // Fully\\Qualified\\ClassOrInterfaceName::class =&gt; Fully\\Qualified\\ClassName::class, ], // etc. For step #3, an alternative to storing a configuration is dynamically associating /awesome-home to a directory in code (probably within a factory). This approach could be useful if the directory of the assets isn't know until runtime. use Psr\\Container\\ContainerInterface; use Mezzio\\Template\\TemplateRendererInterface; use Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface; class AwesomeHomeHandlerFactory { public function __invoke(ContainerInterface $container) : DocumentationViewHandler { // Establish location for the home template assets $repo = $container-&gt;get(FileLocationRepositoryInterface::class); $repo-&gt;addMappedDocumentRoot( 'awesome-home', realpath(__DIR__ . '/../../templates/home') ); return new AwesomeHomeHandler( $container-&gt;get(TemplateRendererInterface::class) ); } } When the template renders, the client will request /awesome-home/style.css , which the StaticMappedResourceHandler will now retrieve from the templates/home/ folder of the module. Mezzio\\Swoole\\StaticMappedResourceHandler uses the Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepository (which implements Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface ) to maintain an association of URI prefixes with file directories. If you require using a file location that requires authentication, decompression, etc. you can override the default functionality by creating your own implementation of Mezzio\\Swoole\\StaticResourceHandler\\FileLocationRepositoryInterface .","title":"Static Resources"},{"location":"v4/static-resources/#static-resources","text":"One feature of a web server is the ability to serve static files from your filesystem. mezzio-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Mezzio\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Mezzio\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Mezzio\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Disabling static resources By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ];","title":"Static Resources"},{"location":"v4/static-resources/#middleware","text":"The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers).","title":"Middleware"},{"location":"v4/static-resources/#configuration","text":"We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'mezzio-swoole' =&gt; [ 'swoole-http-server' =&gt; [ 'static-files' =&gt; [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' =&gt; true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' =&gt; '/path/to/static/files/to/serve', // Extension =&gt; content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' =&gt; [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' =&gt; 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' =&gt; 'weak|strong', // gzip options 'gzip' =&gt; [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' =&gt; 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' =&gt; [ 'regex' =&gt; [ 'cache-control' =&gt; [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' =&gt; bool, // Emit a Last-Modified header? 'etag' =&gt; bool, // Emit an ETag header? ], ], ], ], ], ];","title":"Configuration"},{"location":"v4/static-resources/#writing-middleware","text":"Static resource middleware must implement Mezzio\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Mezzio\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Mezzio\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() .","title":"Writing Middleware"},{"location":"v4/static-resources/#alternative-static-resource-handlers","text":"As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Mezzio\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Mezzio\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Mezzio\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Alternative static resource handlers"},{"location":"v4/static-resources/#example-alternate-static-resource-handler-staticmappedresourcehandler","text":"Since 2.7.0 The default static resource handler, Mezzio\\Swoole\\StaticResourceHandler , requires all files to be in the specified document root directory (by default, \"public\") when instantiating the handler. If you are using modules generating templates with associated file assets (JavaScript, CSS, etc.), those files must be copied to the \"public\" directory if you wish to allow access to them. This can be done via scripting, but is one more step to consider when testing or deploying a site. Ideally, a module should be able to contain both its template and any dependencies that template relies upon. For example, assume you have a module, AwesomeModule, with a handler called \"HomeHandler\", which renders the 'home' template. You designate the prefix, /awesome-home for rendering the assets. The structure of your module files looks like this: AwesomeModule ├── src | ├── Handler | | ├── HomeHandler.php | | ├── HomeHandlerFactory.php | ├── ConfigProvider.php ├── templates │ ├── home | | ├── home.html | | ├── style.css │ ├── layouts In your home.html template, you can refer to the style.css file, using /awesome-home as follows: &lt;link href=\"/awesome-home/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt; Currently, however, this will cause errors, as the stylesheet will not be available under the public/ tree of the application. You would need to copy or symlink the files to the appropriate location to make that work. The StaticMappedResourceHandler solves this problem.","title":"Example alternate static resource handler: StaticMappedResourceHandler"},{"location":"v4/table/","text":"Using Swoole Tables in Your Application Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor. Initialize the Table Within the Constructor You must call your table's create() method, and this must be done prior to initializing any worker processes; if you fail to do so, your table will not work. We recommend doing this in your table class's constructor. Creating a Table As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this-&gt;column('x', self::TYPE_FLOAT); $this-&gt;column('y', self::TYPE_FLOAT); $this-&gt;column('z', self::TYPE_FLOAT); $this-&gt;create(); } } Creating Your Table Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' =&gt; [ // ... Vector3dTable::class =&gt; new Vector3dTable(), ], ]; } Using the Table Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container-&gt;get(Vector3dTable::class) (to use our previous example). Troubleshooting If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table-&gt;create() in your custom table's constructor.","title":"Using Swoole Tables"},{"location":"v4/table/#using-swoole-tables-in-your-application","text":"Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor.","title":"Using Swoole Tables in Your Application"},{"location":"v4/table/#creating-a-table","text":"As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this-&gt;column('x', self::TYPE_FLOAT); $this-&gt;column('y', self::TYPE_FLOAT); $this-&gt;column('z', self::TYPE_FLOAT); $this-&gt;create(); } }","title":"Creating a Table"},{"location":"v4/table/#creating-your-table","text":"Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' =&gt; [ // ... Vector3dTable::class =&gt; new Vector3dTable(), ], ]; }","title":"Creating Your Table"},{"location":"v4/table/#using-the-table","text":"Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container-&gt;get(Vector3dTable::class) (to use our previous example).","title":"Using the Table"},{"location":"v4/table/#troubleshooting","text":"If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table-&gt;create() in your custom table's constructor.","title":"Troubleshooting"},{"location":"v4/cookbook/provide-a-request-id/","text":"Provide a unique ID in your request The problem You want a request-specific identifier via an HTTP request header for purposes of logging, tracking, etc. If you add it via middleware, however, it is not present in your access logs. Request identifiers are usually generated at the web-server level. When you use dedicated web servers such as Apache or nginx, a load balancer, or a reverse proxy, these can be configured to create and inject a request ID before it reaches your application. However, when using mezzio-swoole, the request handler runner we create is your web server. It has listeners that take care of logging, which means that the request generated must already have the identifier if you want to be able to log it. This poses a problem: normally you will use middleware to propagate changes to the request. How can you do it at the Swoole web server level? The solution The answer is to provide a delegator factory on the service that converts the Swoole HTTP request instance into the equivalent PSR-7 HTTP request instance that is then passed to your application. mezzio-swoole maps the Psr\\Http\\Message\\ServerRequestInterface service to its Mezzio\\Swoole\\ServerRequestSwooleFactory . That factory returns a callable that accepts a Swoole\\HTTP\\Request instance and returns a Psr\\Http\\Message\\ServerRequestInterface instance. As such, your delegator factory will need to return a callable with the same signature. In the following example, we use ramsey/uuid to generate a unique request ID, and add it to an X-Request-ID header when returning the request. // In your App module's top-level source directory declare(strict_types=1); namespace App; use Psr\\Container\\ContainerInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Ramsey\\Uuid\\Uuid; use Swoole\\Http\\Request as SwooleHttpRequest; class ServerRequestIdDecorator { public function __invoke(ContainerInterface $container, string $serviceName, callable $factory): callable { return static fn (SwooleHttpRequest $swooleRequest): ServerRequestInterface =&gt; $factory($swooleRequest) -&gt;withHeader('X-Request-ID', Uuid::uuid1()); } } Then, in our App module's ConfigProvider , we would modify the dependency configuration to add the following: public function getDependencies(): array { return [ 'delegators' =&gt; [ \\Psr\\Http\\Message\\ServerRequestInterface::class =&gt; [ ServerRequestIdDecorator::class, ], ], ]; } This approach: Keeps the logic close to the web server. Utilizes facilities already built-in to Mezzio and mezzio-swoole. Allows other code to perform similar work in order to manipulate and modify the request.","title":"Provide a unique ID in your request"},{"location":"v4/cookbook/provide-a-request-id/#provide-a-unique-id-in-your-request","text":"","title":"Provide a unique ID in your request"},{"location":"v4/cookbook/provide-a-request-id/#the-problem","text":"You want a request-specific identifier via an HTTP request header for purposes of logging, tracking, etc. If you add it via middleware, however, it is not present in your access logs. Request identifiers are usually generated at the web-server level. When you use dedicated web servers such as Apache or nginx, a load balancer, or a reverse proxy, these can be configured to create and inject a request ID before it reaches your application. However, when using mezzio-swoole, the request handler runner we create is your web server. It has listeners that take care of logging, which means that the request generated must already have the identifier if you want to be able to log it. This poses a problem: normally you will use middleware to propagate changes to the request. How can you do it at the Swoole web server level?","title":"The problem"},{"location":"v4/cookbook/provide-a-request-id/#the-solution","text":"The answer is to provide a delegator factory on the service that converts the Swoole HTTP request instance into the equivalent PSR-7 HTTP request instance that is then passed to your application. mezzio-swoole maps the Psr\\Http\\Message\\ServerRequestInterface service to its Mezzio\\Swoole\\ServerRequestSwooleFactory . That factory returns a callable that accepts a Swoole\\HTTP\\Request instance and returns a Psr\\Http\\Message\\ServerRequestInterface instance. As such, your delegator factory will need to return a callable with the same signature. In the following example, we use ramsey/uuid to generate a unique request ID, and add it to an X-Request-ID header when returning the request. // In your App module's top-level source directory declare(strict_types=1); namespace App; use Psr\\Container\\ContainerInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Ramsey\\Uuid\\Uuid; use Swoole\\Http\\Request as SwooleHttpRequest; class ServerRequestIdDecorator { public function __invoke(ContainerInterface $container, string $serviceName, callable $factory): callable { return static fn (SwooleHttpRequest $swooleRequest): ServerRequestInterface =&gt; $factory($swooleRequest) -&gt;withHeader('X-Request-ID', Uuid::uuid1()); } } Then, in our App module's ConfigProvider , we would modify the dependency configuration to add the following: public function getDependencies(): array { return [ 'delegators' =&gt; [ \\Psr\\Http\\Message\\ServerRequestInterface::class =&gt; [ ServerRequestIdDecorator::class, ], ], ]; } This approach: Keeps the logic close to the web server. Utilizes facilities already built-in to Mezzio and mezzio-swoole. Allows other code to perform similar work in order to manipulate and modify the request.","title":"The solution"},{"location":"v4/cookbook/static-resource-listener-removal/","text":"Removing the StaticResourceRequestListener By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ];","title":"Removing the StaticResourceRequestListener"},{"location":"v4/cookbook/static-resource-listener-removal/#removing-the-staticresourcerequestlistener","text":"By default, we ship with static resource handling enabled. This is done by having the Mezzio\\Swoole\\Event\\StaticResourceRequestListener in the list of listeners provided for the Mezzio\\Swoole\\Event\\RequestEvent . To disable that listener, you will need to replace the set of listeners for that event, to include only the Mezzio\\Swoole\\Event\\RequestHandlerRequestListener . You can do that in your application configuration as follows: // in config/autoload/dependencies.global.php: use Laminas\\Stdlib\\ArrayUtils\\MergeReplaceKey; use Mezzio\\Swoole\\Event; return [ // ... 'mezzio-swoole' =&gt; [ // ... 'swoole-http-server' =&gt; [ // ... 'listeners' =&gt; [ Event\\RequestEvent::class =&gt; new MergeReplaceKey([ Event\\RequestHandlerRequestListener::class, ]), ], ], ], // ... ];","title":"Removing the StaticResourceRequestListener"},{"location":"v4/cookbook/swoole-not-starting/","text":"Swoole-based server always returns home page The problem You have started your Swoole-based web-server using ./vendor/bin/laminas mezzio:swoole:start , but every request is returned with a status 200 response and the contents of the home page. The solution This is generally caused by having the mezzio-swoole configuration provider too early in your application configuration, which then causes the default Mezzio configuration to overwrite the mezzio-swoole application runner. As an example, if the definition of the ConfigAggregator in your config/config.php file looks something like this: $aggregator = new ConfigAggregator([ \\Mezzio\\Swoole\\ConfigProvider::class, \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the position of the Mezzio\\Swoole\\ConfigProvider::class entry at the top. This can happen if you have previously removed the original entry from the config/config.php as provided by the skeleton project, or if you hand-crafted your config/config.php file , and then later used composer require mezzio/mezzio-swoole`, as the component installer injects at the start of the aggregator definition. The mezzio-swoole package provides a custom implementation of an HTTP Handler Runner . Because it defines the same service name as the one provided by laminas/laminas-httphandlerrunner, the mezzio-swoole ConfigProvider must appear later during aggregation to ensure it takes precedence: $aggregator = new ConfigAggregator([ \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, \\Mezzio\\Swoole\\ConfigProvider::class, // &lt;-- Here or later! // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the change in position for the Mezzio\\Swoole\\ConfigProvider:class entry in the above example.","title":"Swoole-based server always returns home page"},{"location":"v4/cookbook/swoole-not-starting/#swoole-based-server-always-returns-home-page","text":"","title":"Swoole-based server always returns home page"},{"location":"v4/cookbook/swoole-not-starting/#the-problem","text":"You have started your Swoole-based web-server using ./vendor/bin/laminas mezzio:swoole:start , but every request is returned with a status 200 response and the contents of the home page.","title":"The problem"},{"location":"v4/cookbook/swoole-not-starting/#the-solution","text":"This is generally caused by having the mezzio-swoole configuration provider too early in your application configuration, which then causes the default Mezzio configuration to overwrite the mezzio-swoole application runner. As an example, if the definition of the ConfigAggregator in your config/config.php file looks something like this: $aggregator = new ConfigAggregator([ \\Mezzio\\Swoole\\ConfigProvider::class, \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the position of the Mezzio\\Swoole\\ConfigProvider::class entry at the top. This can happen if you have previously removed the original entry from the config/config.php as provided by the skeleton project, or if you hand-crafted your config/config.php file , and then later used composer require mezzio/mezzio-swoole`, as the component installer injects at the start of the aggregator definition. The mezzio-swoole package provides a custom implementation of an HTTP Handler Runner . Because it defines the same service name as the one provided by laminas/laminas-httphandlerrunner, the mezzio-swoole ConfigProvider must appear later during aggregation to ensure it takes precedence: $aggregator = new ConfigAggregator([ \\Mezzio\\Plates\\ConfigProvider::class, \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\Router\\FastRouteRouter\\ConfigProvider::class, \\Laminas\\HttpHandlerRunner\\ConfigProvider::class, \\Mezzio\\Swoole\\ConfigProvider::class, // &lt;-- Here or later! // Include cache configuration new \\Laminas\\ConfigAggregator\\ArrayProvider($cacheConfig), \\Mezzio\\Helper\\ConfigProvider::class, \\Mezzio\\ConfigProvider::class, \\Mezzio\\Router\\ConfigProvider::class, \\Laminas\\Diactoros\\ConfigProvider::class, // Default App module config \\App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new \\Laminas\\ConfigAggregator\\PhpFileProvider(realpath(__DIR__) . '/development.config.php'), ], $cacheConfig['config_cache_path']); Note the change in position for the Mezzio\\Swoole\\ConfigProvider:class entry in the above example.","title":"The solution"}]}